<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Algorithms</name>
    </assembly>
    <members>
        <member name="T:Algorithms.Crypto.Digests.Md2Digest">
            <summary>
            MD2 is a cryptographic hash function that takes an input message and produces a 128-bit output, also called a message
            digest or a hash.
            <para>
            A hash function has two main properties: it is easy to compute the hash from the input, but it is hard to find the
            input from the hash or to find two different inputs that produce the same hash.
            </para>
            <para>
            MD2 works by first padding the input message to a multiple of 16 bytes and adding a 16-byte checksum to it. Then, it
            uses a 48-byte auxiliary block and a 256-byte S-table (a fixed permutation of the numbers 0 to 255) to process the
            message in 16-byte blocks.
            </para>
            <para>
            For each block, it updates the auxiliary block by XORing it with the message block and then applying the S-table 18
            times. After all blocks are processed, the first 16 bytes of the auxiliary block become the hash value.
            </para>
            </summary>
        </member>
        <member name="M:Algorithms.Crypto.Digests.Md2Digest.Digest(System.Byte[])">
            <summary>
            Computes the MD2 hash of the input byte array.
            </summary>
            <param name="input">The input byte array to be hashed.</param>
            <returns>The MD2 hash as a byte array.</returns>
        </member>
        <member name="M:Algorithms.Crypto.Digests.Md2Digest.Reset">
            <summary>
            Resets the engine to its initial state.
            </summary>
        </member>
        <member name="M:Algorithms.Crypto.Digests.Md2Digest.ProcessBlock(System.Byte[])">
            <summary>
            Performs the compression step of MD2 hash algorithm.
            </summary>
            <param name="block">The 16 bytes block to be compressed.</param>
            <remarks>
            the compression step is designed to achieve diffusion and confusion, two properties that make it hard to reverse
            or analyze the hash function. Diffusion means that changing one bit of the input affects many bits of the output,
            and confusion means that there is no apparent relation between the input and the output.
            </remarks>
        </member>
        <member name="M:Algorithms.Crypto.Digests.Md2Digest.ProcessCheckSum(System.Byte[])">
            <summary>
            Performs the checksum step of MD2 hash algorithm.
            </summary>
            <param name="block">The 16 bytes block to calculate the checksum.</param>
            <remarks>
            The checksum step ensures that changing any bit of the input message will change about half of the bits of the
            checksum, making it harder to find collisions or preimages.
            </remarks>
        </member>
        <member name="M:Algorithms.Crypto.Digests.Md2Digest.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte.
            </summary>
            <param name="input">The input byte to digest.</param>
        </member>
        <member name="M:Algorithms.Crypto.Digests.Md2Digest.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the message digest with a block of bytes.
            </summary>
            <param name="input">The byte array containing the data.</param>
            <param name="inputOffset">The offset into the byte array where the data starts.</param>
            <param name="length">The length of the data.</param>
        </member>
        <member name="T:Algorithms.Crypto.Paddings.IBlockCipherPadding">
            <summary>
            A common interface that all block cipher padding schemes should follow.
            </summary>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Adds padding bytes to the end of the given block of the data and returns the number of bytes that were added.
            </summary>
            <param name="inputData">The input data array that needs padding.</param>
            <param name="inputOffset">The offset in the input array where the padding should start.</param>
            <returns>The number of bytes added.</returns>
            <remarks>
            This method expects that the input parameter <paramref name="inputData"/> contains the last block of plain text
            that needs to be padded. This means that the value of <paramref name="inputData"/> has to have the same value as
            the last block of plain text. The reason for this is that some modes such as the <see cref="T:Algorithms.Crypto.Paddings.TbcPadding"/> base the
            padding value on the last byte of the plain text.
            </remarks>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.IBlockCipherPadding.RemovePadding(System.Byte[])">
            <summary>
            Removes the padding bytes from the given block of data and returns the original data as a new array.
            </summary>
            <param name="inputData">The input data array containing the padding.</param>
            <returns>The input data without the padding as a new byte array.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the input data has invalid padding.</exception>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.IBlockCipherPadding.GetPaddingCount(System.Byte[])">
            <summary>
            Gets the number of padding bytes in the input data.
            </summary>
            <param name="input">The input data array that has padding.</param>
            <returns>The number of padding bytes in the input data.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the input data has invalid padding.</exception>
        </member>
        <member name="T:Algorithms.Crypto.Paddings.Iso10126D2Padding">
            <summary>
            <para>
            This class implements the ISO10126d2 padding scheme, which is a standard way of padding data to fit a certain block
            size.
            </para>
            <para>
            ISO10126d2 padding adds N-1 random bytes and one byte of value N to the end of the data, where N is the number of
            bytes needed to reach the block size. For example, if the block size is 16 bytes, and the data is 10 bytes long, then
            5 random bytes and a byte with value 6 will be added to the end of data. This way the padded data will be 16 bytes
            long and can be encrypted or decrypted by a block cipher algorithm.
            </para>
            <para>
            The padding can easily be removed after decryption by looking at the last byte and discarding that many bytes from
            the end of the data.
            </para>
            </summary>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.Iso10126D2Padding.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Adds random padding to the input data array to make it a multiple of the block size according to the
            ISO10126d2 standard.
            </summary>
            <param name="inputData">The input data array that needs to be padded.</param>
            <param name="inputOffset">The offset in the input data array where the padding should start.</param>
            <returns>The number of bytes added as padding.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown when there is not enough space in the input array for padding.
            </exception>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.Iso10126D2Padding.RemovePadding(System.Byte[])">
            <summary>
            Removes the padding from the input data array and returns the original data.
            </summary>
            <param name="inputData">
            The input data with ISO10126d2 padding. Must not be null and must have a valid length and padding.
            </param>
            <returns>
            The input data without the padding as a new byte array.
            </returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the padding length is invalid.
            </exception>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.Iso10126D2Padding.GetPaddingCount(System.Byte[])">
            <summary>
            Gets the number of padding bytes from the input data array.
            </summary>
            <param name="input">The input data array that has been padded.</param>
            <returns>The number of padding bytes.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the input is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the padding block is corrupted.</exception>
        </member>
        <member name="T:Algorithms.Crypto.Paddings.Iso7816D4Padding">
            <summary>
            <para>
            ISO 7816-4 padding is a padding scheme that is defined in the ISO/IEC 7816-4 documentation.
            </para>
            <para>
            It is used for adding data to the end of a message that needs to be encrypted or decrypted by a block cipher.
            </para>
            ISO 7816-4 padding works as follows:
            <para>
            The first byte of the padding is 0x80, which is the hexadecimal representation of the binary value 10000000. This
            byte indicates the start of the padding.
            </para>
            <para>
            All other bytes of the padding are 0x00, which is the hexadecimal representation of the binary value 00000000. These
            bytes fill up the remaining space in the last block.
            </para>
            <para>
            The padding can be of any size, from 1 byte to the block size. For example, if the block size is 8 bytes and the
            message has 5 bytes, then 3 bytes of padding are needed. The padding would be <c>0x80 0x00 0x00</c>.
            </para>
            <para>
            ISO 7816-4 padding is also known as bit padding,because it simply places a single 1 bit after the plaintext, followed
            by 0 valued bits up to the block size. It works for both byte-oriented and bit-oriented protocols, as it does not
            depend on any specific character encoding or representation.
            </para>
            </summary>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.Iso7816D4Padding.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Adds padding to the input data according to the ISO 7816-4 standard.
            </summary>
            <param name="inputData">The input data array that needs padding.</param>
            <param name="inputOffset">The offset in the input data array where the padding should start.</param>
            <returns>The number of bytes added as padding.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown when there is not enough space in the input array for padding or when the input offset is invalid.
            </exception>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.Iso7816D4Padding.RemovePadding(System.Byte[])">
            <summary>
            Removes the padding from the input data array and returns the original data.
            </summary>
            <param name="inputData">
            The input data with ISO 7816-4 padding. Must not be null and must have a valid length and padding.
            </param>
            <returns>The input data without the padding as a new byte array.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the input data has invalid padding.
            </exception>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.Iso7816D4Padding.GetPaddingCount(System.Byte[])">
            <summary>
            Gets the number of padding bytes in the input data according to the ISO 7816-4 standard.
            </summary>
            <param name="input">The input data array that has padding.</param>
            <returns>The number of padding bytes in the input data.</returns>
            <exception cref="T:System.ArgumentException"> Thrown when the input data has invalid padding.</exception>
        </member>
        <member name="T:Algorithms.Crypto.Paddings.Pkcs7Padding">
            <summary>
            <para>
            This class implements the PKCS7 padding scheme, which is a standard way of padding data to fit a certain block size.
            </para>
            <para>
            PKCS7 padding adds N bytes of value N to the end of the data, where N is the number of bytes needed to reach the block size.
            For example, if the block size is 16 bytes, and the data is 11 bytes long, then 5 bytes of value 5 will be added to the
            end of the data. This way, the padded data will be 16 bytes long and can be encrypted or decrypted by a block cipher algorithm.
            </para>
            <para>
            The padding can be easily removed after decryption by looking at the last byte and subtracting that many bytes from the
            end of the data.
            </para>
            <para>
            This class supports any block size from 1 to 255 bytes, and can be used with any encryption algorithm that requires
            padding, such as AES.
            </para>
            </summary>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.Pkcs7Padding.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Adds padding to the end of a byte array according to the PKCS#7 standard.
            </summary>
            <param name="input">The byte array to be padded.</param>
            <param name="inputOffset">The offset from which to start padding.</param>
            <returns>The padding value that was added to each byte.</returns>
            <exception cref="T:System.ArgumentException">
            If the input array does not have enough space to add <c>blockSize</c> bytes as padding.
            </exception>
            <remarks>
            The padding value is equal to the number of of bytes that are added to the array.
            For example, if the input array has a length of 16 and the input offset is 10,
            then 6 bytes with the value 6 will be added to the end of the array.
            </remarks>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.Pkcs7Padding.RemovePadding(System.Byte[])">
            <summary>
            Removes the PKCS7 padding from the given input data.
            </summary>
            <param name="input">The input data with PKCS7 padding. Must not be null and must have a vaild length and padding.</param>
            <returns>The input data without the padding as a new byte array.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if the input data is null, has an invalid length, or has an invalid padding.
            </exception>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.Pkcs7Padding.GetPaddingCount(System.Byte[])">
            <summary>
            Gets the number of padding bytes in the given input data according to the PKCS7 padding scheme.
            </summary>
            <param name="input">The input data with PKCS7 padding. Must not be null and must have a valid padding.</param>
            <returns>The number of padding bytes in the input data.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if the input data is null or has an invalid padding.
            </exception>
            <remarks>
            This method uses bitwise operations to avoid branching.
            </remarks>
        </member>
        <member name="T:Algorithms.Crypto.Paddings.TbcPadding">
            <summary>
            <para>
            Trailing-Bit-Complement padding is a padding scheme that is defined in the ISO/IEC 9797-1 standard.
            </para>
            <para>
            It is used for adding data to the end of a message that needs to be encrypted or decrypted by a block cipher.
            </para>
            <para>
            The padding bytes are either 0x00 or 0xFF, depending on the last bit of the original data. For example, if the last
            bit of the original data is 0, then the padding bytes are 0xFF; if the last bit is 1, then the padding bytes are 0x00.
            The padding bytes are added at the end of the data block until the desired length is reached.
            </para>
            </summary>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.TbcPadding.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Adds padding to the input array according to the TBC standard.
            </summary>
            <param name="input">The input array to be padded.</param>
            <param name="inputOffset">The offset in the input array where the padding starts.</param>
            <returns>The number of bytes that were added.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the input array does not have enough space for padding.</exception>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.TbcPadding.RemovePadding(System.Byte[])">
            <summary>
            Removes the padding from a byte array according to the Trailing-Bit-Complement padding algorithm.
            </summary>
            <param name="input">The byte array to remove the padding from.</param>
            <returns>A new byte array without the padding.</returns>
            <remarks>
            This method assumes that the input array has padded with either 0x00 or 0xFF bytes, depending on the last bit of
            the original data. The method works by finding the last byte that does not match the padding code and copying all
            the bytes up to that point into a new array. If the input array is not padded or has an invalid padding, the
            method may return incorrect results.
            </remarks>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.TbcPadding.GetPaddingCount(System.Byte[])">
            <summary>
            Returns the number of padding bytes in a byte array according to the Trailing-Bit-Complement padding algorithm.
            </summary>
            <param name="input">The byte array to check for padding.</param>
            <returns>The number of padding bytes in the input array.</returns>
            <remarks>
            This method assumes that the input array has been padded with either 0x00 or 0xFF bytes, depending on the last
            bit of the original data. The method works by iterating backwards from the end of the array and counting the
            number of bytes that match the padding code. The method uses bitwise operations to optimize the performance and
            avoid branching. If the input array is not padded or has an invalid padding, the method may return incorrect
            results.
            </remarks>
        </member>
        <member name="T:Algorithms.Crypto.Paddings.X932Padding">
            <summary>
            <para>
            X9.32 padding is a padding scheme for symmetric encryption algorithms that is based on the ANSI X9.32 standard.
            </para>
            <para>
            It adds bytes with value equal to 0 up to the end of the plaintext. For example if the plaintext is 13 bytes long
            and the block size is 16 bytes, then 2 bytes with value 0 will be added as padding. The last byte indicates the
            number of padding bytes.
            </para>
            <para>
            If random padding mode is selected then random bytes are added before the padding bytes. For example, if the plaintext
            is 13 bytes long, then 2 random bytes will be added as padding. Again the last byte indicates the number of padding
            bytes.
            </para>
            </summary>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.X932Padding.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Algorithms.Crypto.Paddings.X932Padding"/> class with the specified padding mode.
            </summary>
            <param name="useRandomPadding">A boolean value that indicates whether to use random bytes as padding or not.</param>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.X932Padding.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Adds padding to the input data according to the X9.23 padding scheme.
            </summary>
            <param name="inputData">The input data array to be padded.</param>
            <param name="inputOffset">The offset in the input data array where the padding should start.</param>
            <returns>The number of padding bytes added.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the input offset is greater than or equal to the input data length.
            </exception>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.X932Padding.RemovePadding(System.Byte[])">
            <summary>
            Removes padding from the input data according to the X9.23 padding scheme.
            </summary>
            <param name="inputData">The input data array to be unpadded.</param>
            <returns>The unpadded data array.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the input data is empty or has an invalid padding length.
            </exception>
        </member>
        <member name="M:Algorithms.Crypto.Paddings.X932Padding.GetPaddingCount(System.Byte[])">
            <summary>
            Gets the number of padding bytes in the input data according to the X9.23 padding scheme.
            </summary>
            <param name="input">The input data array to be checked.</param>
            <returns>The number of padding bytes in the input data.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the input data has a corrupted padding block.
            </exception>
        </member>
        <member name="T:Algorithms.DataCompression.BurrowsWheelerTransform">
            <summary>
                The Burrows–Wheeler transform (BWT) rearranges a character string into runs of similar characters.
                This is useful for compression, since it tends to be easy to compress a string that has runs of repeated
                characters.
                See <a href="https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform">here</a> for more info.
            </summary>
        </member>
        <member name="M:Algorithms.DataCompression.BurrowsWheelerTransform.Encode(System.String)">
            <summary>
                Encodes the input string using BWT and returns encoded string and the index of original string in the sorted
                rotation matrix.
            </summary>
            <param name="s">Input string.</param>
        </member>
        <member name="M:Algorithms.DataCompression.BurrowsWheelerTransform.Decode(System.String,System.Int32)">
            <summary>
                Decodes the input string and returns original string.
            </summary>
            <param name="s">Encoded string.</param>
            <param name="index">Index  of original string in the sorted rotation matrix.</param>
        </member>
        <member name="T:Algorithms.DataCompression.HuffmanCompressor">
            <summary>
                Greedy lossless compression algorithm.
            </summary>
        </member>
        <member name="M:Algorithms.DataCompression.HuffmanCompressor.Compress(System.String)">
            <summary>
                Given an input string, returns a new compressed string
                using huffman encoding.
            </summary>
            <param name="uncompressedText">Text message to compress.</param>
            <returns>Compressed string and keys to decompress it.</returns>
        </member>
        <member name="M:Algorithms.DataCompression.HuffmanCompressor.GetListNodesFromText(System.String)">
            <summary>
                Finds frequency for each character in the text.
            </summary>
            <returns>Symbol-frequency array.</returns>
        </member>
        <member name="T:Algorithms.DataCompression.HuffmanCompressor.ListNode">
            <summary>
                Represents tree structure for the algorithm.
            </summary>
        </member>
        <member name="T:Algorithms.DataCompression.ShannonFanoCompressor">
            <summary>
                Greedy lossless compression algorithm.
            </summary>
        </member>
        <member name="M:Algorithms.DataCompression.ShannonFanoCompressor.Compress(System.String)">
            <summary>
                Given an input string, returns a new compressed string
                using Shannon-Fano encoding.
            </summary>
            <param name="uncompressedText">Text message to compress.</param>
            <returns>Compressed string and keys to decompress it.</returns>
        </member>
        <member name="M:Algorithms.DataCompression.ShannonFanoCompressor.GetListNodeFromText(System.String)">
            <summary>
                Finds frequency for each character in the text.
            </summary>
            <returns>Symbol-frequency array.</returns>
        </member>
        <member name="T:Algorithms.DataCompression.ShannonFanoCompressor.ListNode">
            <summary>
                Represents tree structure for the algorithm.
            </summary>
        </member>
        <member name="T:Algorithms.DataCompression.Translator">
            <summary>
                Provides method for text conversion by key mapping.
            </summary>
        </member>
        <member name="M:Algorithms.DataCompression.Translator.Translate(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
                Converts the input text according to the translation keys.
            </summary>
            <param name="text">Input text.</param>
            <param name="translationKeys">Translation keys used for text matching.</param>
            <returns>Converted text according to the translation keys.</returns>
        </member>
        <member name="T:Algorithms.Encoders.BlowfishEncoder">
            <summary>
            <para>
            The Blowfish algorithm is a symmetric-key block cipher, which means it uses the same secret key to encrypt and
            decrypt data. It was designed by Bruce Schneier in 1993.
            </para>
            <para>
            The blowfish algorithm works on 64-bit blocks of data, which are divided into two 32-bit halves: left and right.
            It uses a variable-length key, from 32 bits to 448 bits, to generate 18 subkeys and four S-boxes, which are arrays
            of 256 32-bit words. The subkeys and the S-boxes are key-dependent, meaning that they change according to the secret key.
            </para>
            <para>
            The blowfish algorithm performs 16 rounds of encryption or decryption on each block of data, using a Feistel network
            structure. In each round, the left half is XORed with a subkey, then passed through a function F that applies four
            S-box lookups and two XOR operations. The output of F is then XORed with the right half. The left and right halves
            are swapped at the end of each round, except for the last one. The final output is XORed with two more subkeys to
            produce the encrypted or decrypted block.
            </para>
            <see href="https://en.wikipedia.org/wiki/Blowfish_%28cipher%29">Blowfish on Wikipedia</see>.
            </summary>
        </member>
        <member name="M:Algorithms.Encoders.BlowfishEncoder.GenerateKey(System.String)">
            <summary>
                Generate a key for the encryption algorithm based on the given string parameter.
            </summary>
            <param name="key">The key to generate the subkey from.</param>
        </member>
        <member name="M:Algorithms.Encoders.BlowfishEncoder.Encrypt(System.String)">
            <summary>
            Encrypts a string using the blowfish algorithm.
            </summary>
            <param name="plainText">The string to be encrypted, represented as a hexadecimal string.</param>
            <returns>The encrypted string, represented as a hexadecimal string.</returns>
        </member>
        <member name="M:Algorithms.Encoders.BlowfishEncoder.Decrypt(System.String)">
            <summary>
            Decrypts a string using the blowfish algorithm.
            </summary>
            <param name="cipherText">The string to be decrypted, represented as a hexadecimal string.</param>
            <returns>The decrypted string, represented as a hexadecimal string.</returns>
        </member>
        <member name="M:Algorithms.Encoders.BlowfishEncoder.HexadecimalToBinary(System.String)">
            <summary>
                Converts a hexadecimal string to a binary string.
            </summary>
            <param name="hex">The hexadecimal string to convert.</param>
            <returns>A multiple of 4 binary string representing the hexadecimal input.</returns>
        </member>
        <member name="M:Algorithms.Encoders.BlowfishEncoder.BinaryToHexadecimal(System.String)">
            <summary>
                Converts a binary string to a hexadecimal string.
            </summary>
            <param name="binaryInput">The multiple of 4 binary string to convert.</param>
            <returns>A hexadecimal string representing the binary input.</returns>
        </member>
        <member name="M:Algorithms.Encoders.BlowfishEncoder.Xor(System.String,System.String)">
            <summary>
                Performs a bitwise XOR operation on two hexadecimal strings and returns the result.
            </summary>
            <param name="left">The first hexadecimal string to XOR.</param>
            <param name="right">The second hexadecimal string to XOR.</param>
            <returns>A hexadecimal string representing the XOR of the inputs.</returns>
        </member>
        <member name="M:Algorithms.Encoders.BlowfishEncoder.AddAndMod(System.String,System.String)">
            <summary>
                Adds two hexadecimal strings and returns the result modulo _modVal.
            </summary>
            <param name="left">The first hexadecimal string to add.</param>
            <param name="right">The second hexadecimal string to add.</param>
            <returns>A hexadecimal string representing the sum of the inputs modulo _modVal.</returns>
        </member>
        <member name="M:Algorithms.Encoders.BlowfishEncoder.F(System.String)">
            <summary>
                Performs the F function on a 32-bit input and returns a 32-bit output.
            </summary>
            <param name="plainText">The 32-bit hexadecimal input to the F function.</param>
            <returns>The 32-bit hexadecimal output of the F function.</returns>
            <remarks>
                The F function is a non-linear function that operates on a 32-bit input and produces a 32-bit output. It is used
                to generate the sub-keys and to perform the encryption and decryption of the data blocks.
            </remarks>
        </member>
        <member name="M:Algorithms.Encoders.BlowfishEncoder.Round(System.Int32,System.String)">
            <summary>
            Performs one round of the blowfish encryption on a 64-bit block of data.
            </summary>
            <param name="feistelRound">The round number, from 0 to 15, indicating which subkey from the P-array to use.</param>
            <param name="plainText">The 64-bit block of data to be encrypted or decrypted, represented as a hexadecimal string.</param>
            <returns>The encrypted or decrypted block of data, represented as a hexadecimal string.</returns>
        </member>
        <member name="T:Algorithms.Encoders.CaesarEncoder">
            <summary>
                Encodes using caesar cypher.
            </summary>
        </member>
        <member name="M:Algorithms.Encoders.CaesarEncoder.Encode(System.String,System.Int32)">
            <summary>
                Encodes text using specified key,
                time complexity: O(n),
                space complexity: O(n),
                where n - text length.
            </summary>
            <param name="text">Text to be encoded.</param>
            <param name="key">Key that will be used to encode the text.</param>
            <returns>Encoded text.</returns>
        </member>
        <member name="M:Algorithms.Encoders.CaesarEncoder.Decode(System.String,System.Int32)">
            <summary>
                Decodes text that was encoded using specified key,
                time complexity: O(n),
                space complexity: O(n),
                where n - text length.
            </summary>
            <param name="text">Text to be decoded.</param>
            <param name="key">Key that was used to encode the text.</param>
            <returns>Decoded text.</returns>
        </member>
        <member name="T:Algorithms.Encoders.FeistelCipher">
            <summary>
                Encodes using Feistel cipher.
                https://en.wikipedia.org/wiki/Feistel_cipher
                In cryptography, a Feistel cipher (also known as Luby–Rackoff block cipher)
                is a symmetric structure used in the construction of block ciphers,
                named after the German-born physicist and cryptographer Horst Feistel
                who did pioneering research while working for IBM (USA)
                A large proportion of block ciphers use the scheme, including the US DES,
                the Soviet/Russian GOST and the more recent Blowfish and Twofish ciphers.
            </summary>
        </member>
        <member name="M:Algorithms.Encoders.FeistelCipher.Encode(System.String,System.UInt32)">
            <summary>
                Encodes text using specified key,
                where n - text length.
            </summary>
            <param name="text">Text to be encoded.</param>
            <param name="key">Key that will be used to encode the text.</param>
            <exception cref="T:System.ArgumentException">Error: key should be more than 0x00001111 for better encoding, key=0 will throw DivideByZero exception.</exception>
            <returns>Encoded text.</returns>
        </member>
        <member name="M:Algorithms.Encoders.FeistelCipher.Decode(System.String,System.UInt32)">
            <summary>
                Decodes text that was encoded using specified key.
            </summary>
            <param name="text">Text to be decoded.</param>
            <param name="key">Key that was used to encode the text.</param>
            <exception cref="T:System.ArgumentException">Error: key should be more than 0x00001111 for better encoding, key=0 will throw DivideByZero exception.</exception>
            <exception cref="T:System.ArgumentException">Error: The length of text should be divisible by 16 as it the block lenght is 16 bytes.</exception>
            <returns>Decoded text.</returns>
        </member>
        <member name="T:Algorithms.Encoders.HillEncoder">
            <summary>
                Lester S. Hill's polygraphic substitution cipher,
                without representing letters using mod26, using
                corresponding "(char)value" instead.
            </summary>
        </member>
        <member name="M:Algorithms.Encoders.HillEncoder.BuildStringFromArray(System.Double[])">
            <summary>
                Converts elements from the array to their corresponding Unicode characters.
            </summary>
            <param name="arr">array of vectors.</param>
            <returns>Message.</returns>
        </member>
        <member name="M:Algorithms.Encoders.HillEncoder.MatrixCipher(System.Double[],System.Double[0:,0:])">
            <summary>
                Multiplies the key for the given scalar.
            </summary>
            <param name="vector">list of splitted words as numbers.</param>
            <param name="key">Cipher selected key.</param>
            <returns>Ciphered vector.</returns>
        </member>
        <member name="M:Algorithms.Encoders.HillEncoder.MergeArrayList(System.Double[][])">
            <summary>
                Given a list of vectors, returns a single array of elements.
            </summary>
            <param name="list">List of ciphered arrays.</param>
            <returns>unidimensional list.</returns>
        </member>
        <member name="M:Algorithms.Encoders.HillEncoder.SplitToCharArray(System.String[])">
            <summary>
                Splits the input text message as chunks of words.
            </summary>
            <param name="chunked">chunked words list.</param>
            <returns>spliiter char array.</returns>
        </member>
        <member name="M:Algorithms.Encoders.HillEncoder.ChunkTextToArray(System.String)">
            <summary>
                Chunks the input text message.
            </summary>
            <param name="text">text message.</param>
            <returns>array of words.</returns>
        </member>
        <member name="M:Algorithms.Encoders.HillEncoder.FillGaps(System.String)">
            <summary>
                Fills a text message with spaces at the end
                to enable a simple split by 3-length-word.
            </summary>
            <param name="text">Text Message.</param>
            <returns>Modified text Message.</returns>
        </member>
        <member name="M:Algorithms.Encoders.HillEncoder.UnFillGaps(System.String)">
            <summary>
                Removes the extra spaces included on the cipher phase.
            </summary>
            <param name="text">Text message.</param>
            <returns>Deciphered Message.</returns>
        </member>
        <member name="M:Algorithms.Encoders.HillEncoder.MatrixDeCipher(System.Double[],System.Double[0:,0:])">
            <summary>
                Finds the inverse of the given matrix using a linear equation solver.
            </summary>
            <param name="vector">Splitted words vector.</param>
            <param name="key">Key used for the cipher.</param>
            <returns>TODO.</returns>
        </member>
        <member name="T:Algorithms.Encoders.IEncoder`1">
            <summary>
                Encodes and decodes text based on specified key.
            </summary>
            <typeparam name="TKey">Type of the key.</typeparam>
        </member>
        <member name="M:Algorithms.Encoders.IEncoder`1.Encode(System.String,`0)">
            <summary>
                Encodes text using specified key.
            </summary>
            <param name="text">Text to be encoded.</param>
            <param name="key">Key that will be used to encode the text.</param>
            <returns>Encoded text.</returns>
        </member>
        <member name="M:Algorithms.Encoders.IEncoder`1.Decode(System.String,`0)">
            <summary>
                Decodes text that was encoded using specified key.
            </summary>
            <param name="text">Text to be decoded.</param>
            <param name="key">Key that was used to encode the text.</param>
            <returns>Decoded text.</returns>
        </member>
        <member name="T:Algorithms.Encoders.NysiisEncoder">
            <summary>
                Class for NYSIIS encoding strings.
            </summary>
        </member>
        <member name="M:Algorithms.Encoders.NysiisEncoder.Encode(System.String)">
            <summary>
                Encodes a string using the NYSIIS Algorithm.
            </summary>
            <param name="text">The string to encode.</param>
            <returns>The NYSIIS encoded string (all uppercase).</returns>
        </member>
        <member name="T:Algorithms.Encoders.SoundexEncoder">
            <summary>
                Class for Soundex encoding strings.
            </summary>
        </member>
        <member name="M:Algorithms.Encoders.SoundexEncoder.Encode(System.String)">
            <summary>
                Encodes a string using the Soundex Algorithm.
            </summary>
            <param name="text">The string to encode.</param>
            <returns>The Soundex encoded string (one uppercase character and three digits).</returns>
        </member>
        <member name="T:Algorithms.Encoders.VigenereEncoder">
            <summary>
                Encodes using vigenere cypher.
            </summary>
        </member>
        <member name="M:Algorithms.Encoders.VigenereEncoder.Encode(System.String,System.String)">
            <summary>
                Encodes text using specified key,
                time complexity: O(n),
                space complexity: O(n),
                where n - text length.
            </summary>
            <param name="text">Text to be encoded.</param>
            <param name="key">Key that will be used to encode the text.</param>
            <returns>Encoded text.</returns>
        </member>
        <member name="M:Algorithms.Encoders.VigenereEncoder.Decode(System.String,System.String)">
            <summary>
                Decodes text that was encoded using specified key,
                time complexity: O(n),
                space complexity: O(n),
                where n - text length.
            </summary>
            <param name="text">Text to be decoded.</param>
            <param name="key">Key that was used to encode the text.</param>
            <returns>Decoded text.</returns>
        </member>
        <member name="T:Algorithms.Graph.BellmanFord`1">
            <summary>
            Bellman-Ford algorithm on directed weighted graph.
            </summary>
            <typeparam name="T">Generic type of data in the graph.</typeparam>
        </member>
        <member name="M:Algorithms.Graph.BellmanFord`1.Run(DataStructures.Graph.Vertex{`0})">
            <summary>
            Runs the Bellman-Ford algorithm to find the shortest distances from the source vertex to all other vertices.
            </summary>
            <param name="sourceVertex">Source vertex for shortest path calculation.</param>
            <returns>
            A dictionary containing the shortest distances from the source vertex to all other vertices.
            If a vertex is unreachable from the source, it will have a value of double.PositiveInfinity.
            </returns>
        </member>
        <member name="T:Algorithms.Graph.BreadthFirstSearch`1">
            <summary>
            Breadth First Search - algorithm for traversing graph.
            Algorithm starts from root node that is selected by the user.
            Algorithm explores all nodes at the present depth.
            </summary>
            <typeparam name="T">Vertex data type.</typeparam>
        </member>
        <member name="M:Algorithms.Graph.BreadthFirstSearch`1.VisitAll(DataStructures.Graph.IDirectedWeightedGraph{`0},DataStructures.Graph.Vertex{`0},System.Action{DataStructures.Graph.Vertex{`0}})">
            <summary>
            Traverses graph from start vertex.
            </summary>
            <param name="graph">Graph instance.</param>
            <param name="startVertex">Vertex that search starts from.</param>
            <param name="action">Action that needs to be executed on each graph vertex.</param>
        </member>
        <member name="M:Algorithms.Graph.BreadthFirstSearch`1.Bfs(DataStructures.Graph.IDirectedWeightedGraph{`0},DataStructures.Graph.Vertex{`0},System.Action{DataStructures.Graph.Vertex{`0}},System.Collections.Generic.HashSet{DataStructures.Graph.Vertex{`0}})">
            <summary>
            Traverses graph from start vertex.
            </summary>
            <param name="graph">Graph instance.</param>
            <param name="startVertex">Vertex that search starts from.</param>
            <param name="action">Action that needs to be executed on each graph vertex.</param>
            <param name="visited">Hash set with visited vertices.</param>
        </member>
        <member name="T:Algorithms.Graph.BreadthFirstTreeTraversal`1">
            <summary>
                Breadth first tree traversal traverses through a binary tree
                by iterating through each level first.
                time complexity: O(n).
                space complexity: O(w) where w is the max width of a binary tree.
            </summary>
            <typeparam name="TKey">Type of key held in binary search tree.</typeparam>
        </member>
        <member name="M:Algorithms.Graph.BreadthFirstTreeTraversal`1.LevelOrderTraversal(DataStructures.BinarySearchTree.BinarySearchTree{`0})">
            <summary>
                Level Order Traversal returns an array of integers in order
                of each level of a binary tree. It uses a queue to iterate
                through each node following breadth first search traversal.
            </summary>
            <param name="tree">Passes the binary tree to traverse.</param>
            <returns>Returns level order traversal.</returns>
        </member>
        <member name="M:Algorithms.Graph.BreadthFirstTreeTraversal`1.DeepestNode(DataStructures.BinarySearchTree.BinarySearchTree{`0})">
            <summary>
                Deepest Node return the deepest node in a binary tree. If more
                than one node is on the deepest level, it is defined as the
                right-most node of a binary tree. Deepest node uses breadth
                first traversal to reach the end.
            </summary>
            <param name="tree">Tree passed to find deepest node.</param>
            <returns>Returns the deepest node in the tree.</returns>
        </member>
        <member name="T:Algorithms.Graph.DepthFirstSearch`1">
            <summary>
            Depth First Search - algorithm for traversing graph.
            Algorithm starts from root node that is selected by the user.
            Algorithm explores as far as possible along each branch before backtracking.
            </summary>
            <typeparam name="T">Vertex data type.</typeparam>
        </member>
        <member name="M:Algorithms.Graph.DepthFirstSearch`1.VisitAll(DataStructures.Graph.IDirectedWeightedGraph{`0},DataStructures.Graph.Vertex{`0},System.Action{DataStructures.Graph.Vertex{`0}})">
            <summary>
            Traverses graph from start vertex.
            </summary>
            <param name="graph">Graph instance.</param>
            <param name="startVertex">Vertex that search starts from.</param>
            <param name="action">Action that needs to be executed on each graph vertex.</param>
        </member>
        <member name="M:Algorithms.Graph.DepthFirstSearch`1.Dfs(DataStructures.Graph.IDirectedWeightedGraph{`0},DataStructures.Graph.Vertex{`0},System.Action{DataStructures.Graph.Vertex{`0}},System.Collections.Generic.HashSet{DataStructures.Graph.Vertex{`0}})">
            <summary>
            Traverses graph from start vertex.
            </summary>
            <param name="graph">Graph instance.</param>
            <param name="startVertex">Vertex that search starts from.</param>
            <param name="action">Action that needs to be executed on each graph vertex.</param>
            <param name="visited">Hash set with visited vertices.</param>
        </member>
        <member name="M:Algorithms.Graph.Dijkstra.DijkstraAlgorithm.GenerateShortestPath``1(DataStructures.Graph.DirectedWeightedGraph{``0},DataStructures.Graph.Vertex{``0})">
            <summary>
            Implementation of the Dijkstra shortest path algorithm for cyclic graphs.
            https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm.
            </summary>
            <param name="graph">Graph instance.</param>
            <param name="startVertex">Starting vertex instance.</param>
            <typeparam name="T">Generic Parameter.</typeparam>
            <returns>List of distances from current vertex to all other vertices.</returns>
            <exception cref="T:System.InvalidOperationException">Exception thrown in case when graph is null or start
            vertex does not belong to graph instance.</exception>
        </member>
        <member name="T:Algorithms.Graph.Dijkstra.DistanceModel`1">
            <summary>
            Entity which represents the Dijkstra shortest distance.
            Contains: Vertex, Previous Vertex and minimal distance from start vertex.
            </summary>
            <typeparam name="T">Generic parameter.</typeparam>
        </member>
        <member name="T:Algorithms.Graph.FloydWarshall`1">
            <summary>
            Floyd Warshall algorithm on directed weighted graph.
            </summary>
            <typeparam name="T">generic type of data in graph.</typeparam>
        </member>
        <member name="M:Algorithms.Graph.FloydWarshall`1.Run(DataStructures.Graph.DirectedWeightedGraph{`0})">
            <summary>
            runs the algorithm.
            </summary>
            <param name="graph">graph upon which to run.</param>
            <returns>
            a 2D array of shortest paths between any two vertices.
            where there is no path between two vertices - double.PositiveInfinity is placed.
            </returns>
        </member>
        <member name="M:Algorithms.Graph.FloydWarshall`1.SetupDistances(DataStructures.Graph.DirectedWeightedGraph{`0})">
            <summary>
            setup adjacency matrix for use by main algorithm run.
            </summary>
            <param name="graph">graph to dissect adjacency matrix from.</param>
            <returns>the adjacency matrix in the format mentioned in Run.</returns>
        </member>
        <member name="M:Algorithms.Graph.IGraphSearch`1.VisitAll(DataStructures.Graph.IDirectedWeightedGraph{`0},DataStructures.Graph.Vertex{`0},System.Action{DataStructures.Graph.Vertex{`0}})">
            <summary>
            Traverses graph from start vertex.
            </summary>
            <param name="graph">Graph instance.</param>
            <param name="startVertex">Vertex that search starts from.</param>
            <param name="action">Action that needs to be executed on each graph vertex.</param>
        </member>
        <member name="T:Algorithms.Graph.Kosaraju`1">
            <summary>
            Implementation of Kosaraju-Sharir's algorithm (also known as Kosaraju's algorithm) to find the
            strongly connected components (SCC) of a directed graph.
            See https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm.
            </summary>
            <typeparam name="T">Vertex data type.</typeparam>
        </member>
        <member name="M:Algorithms.Graph.Kosaraju`1.Visit(DataStructures.Graph.Vertex{`0},DataStructures.Graph.IDirectedWeightedGraph{`0},System.Collections.Generic.HashSet{DataStructures.Graph.Vertex{`0}},System.Collections.Generic.Stack{DataStructures.Graph.Vertex{`0}})">
            <summary>
            First DFS for Kosaraju algorithm: traverse the graph creating a reverse order explore list <paramref name="reversed"/>.
            </summary>
            <param name="v">Vertex to explore.</param>
            <param name="graph">Graph instance.</param>
            <param name="visited">List of already visited vertex.</param>
            <param name="reversed">Reversed list of vertex for the second DFS.</param>
        </member>
        <member name="M:Algorithms.Graph.Kosaraju`1.Assign(DataStructures.Graph.Vertex{`0},DataStructures.Graph.Vertex{`0},DataStructures.Graph.IDirectedWeightedGraph{`0},System.Collections.Generic.Dictionary{DataStructures.Graph.Vertex{`0},DataStructures.Graph.Vertex{`0}})">
            <summary>
            Second DFS for Kosaraju algorithm. Traverse the graph in reversed order
            assigning a root vertex for every vertex that belong to the same SCC.
            </summary>
            <param name="v">Vertex to assign.</param>
            <param name="root">Root vertext, representative of the SCC.</param>
            <param name="graph">Graph with vertex and edges.</param>
            <param name="roots">
            Dictionary that assigns to each vertex the root of the SCC to which it corresponds.
            </param>
        </member>
        <member name="M:Algorithms.Graph.Kosaraju`1.GetRepresentatives(DataStructures.Graph.IDirectedWeightedGraph{`0})">
            <summary>
            Find the representative vertex of the SCC for each vertex on the graph.
            </summary>
            <param name="graph">Graph to explore.</param>
            <returns>A dictionary that assigns to each vertex a root vertex of the SCC they belong. </returns>
        </member>
        <member name="M:Algorithms.Graph.Kosaraju`1.GetScc(DataStructures.Graph.IDirectedWeightedGraph{`0})">
            <summary>
            Get the Strongly Connected Components for the graph.
            </summary>
            <param name="graph">Graph to explore.</param>
            <returns>An array of SCC.</returns>
        </member>
        <member name="T:Algorithms.Graph.MinimumSpanningTree.Kruskal">
            <summary>
                Algorithm to determine the minimum spanning forest of an undirected graph.
            </summary>
            <remarks>
                Kruskal's algorithm is a greedy algorithm that can determine the
                minimum spanning tree or minimum spanning forest of any undirected
                graph. Unlike Prim's algorithm, Kruskal's algorithm will work on
                graphs that are unconnected. This algorithm will always have a
                running time of O(E log V) where E is the number of edges and V is
                the number of vertices/nodes.
                More information: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm .
                Pseudocode and analysis: https://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm .
            </remarks>
        </member>
        <member name="M:Algorithms.Graph.MinimumSpanningTree.Kruskal.Solve(System.Single[0:,0:])">
            <summary>
                Determine the minimum spanning tree/forest of the given graph.
            </summary>
            <param name="adjacencyMatrix">Adjacency matrix representing the graph.</param>
            <returns>Adjacency matrix of the minimum spanning tree/forest.</returns>
        </member>
        <member name="M:Algorithms.Graph.MinimumSpanningTree.Kruskal.Solve(System.Collections.Generic.Dictionary{System.Int32,System.Single}[])">
            <summary>
                Determine the minimum spanning tree/forest of the given graph.
            </summary>
            <param name="adjacencyList">Adjacency list representing the graph.</param>
            <returns>Adjacency list of the minimum spanning tree/forest.</returns>
        </member>
        <member name="M:Algorithms.Graph.MinimumSpanningTree.Kruskal.ValidateGraph(System.Single[0:,0:])">
            <summary>
                Ensure that the given graph is undirected.
            </summary>
            <param name="adj">Adjacency matrix of graph to check.</param>
        </member>
        <member name="M:Algorithms.Graph.MinimumSpanningTree.Kruskal.ValidateGraph(System.Collections.Generic.Dictionary{System.Int32,System.Single}[])">
            <summary>
                Ensure that the given graph is undirected.
            </summary>
            <param name="adj">Adjacency list of graph to check.</param>
        </member>
        <member name="M:Algorithms.Graph.MinimumSpanningTree.Kruskal.Solve(DataStructures.DisjointSet.DisjointSet{System.Int32},DataStructures.DisjointSet.Node{System.Int32}[],System.Single[],System.ValueTuple{System.Int32,System.Int32}[])">
            <summary>
                Determine the minimum spanning tree/forest.
            </summary>
            <param name="set">Disjoint set needed for set operations.</param>
            <param name="nodes">List of nodes in disjoint set associated with each node.</param>
            <param name="edgeWeights">Weights of each edge.</param>
            <param name="connections">Nodes associated with each item in the <paramref name="edgeWeights"/> parameter.</param>
            <returns>Array of edges in the minimum spanning tree/forest.</returns>
        </member>
        <member name="T:Algorithms.Graph.MinimumSpanningTree.PrimMatrix">
            <summary>
                Class that uses Prim's (Jarnik's algorithm) to determine the minimum
                spanning tree (MST) of a given graph. Prim's algorithm is a greedy
                algorithm that can determine the MST of a weighted undirected graph
                in O(V^2) time where V is the number of nodes/vertices when using an
                adjacency matrix representation.
                More information: https://en.wikipedia.org/wiki/Prim%27s_algorithm
                Pseudocode and runtime analysis: https://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm .
            </summary>
        </member>
        <member name="M:Algorithms.Graph.MinimumSpanningTree.PrimMatrix.Solve(System.Single[0:,0:],System.Int32)">
            <summary>
                Determine the minimum spanning tree for a given weighted undirected graph.
            </summary>
            <param name="adjacencyMatrix">Adjacency matrix for graph to find MST of.</param>
            <param name="start">Node to start search from.</param>
            <returns>Adjacency matrix of the found MST.</returns>
        </member>
        <member name="M:Algorithms.Graph.MinimumSpanningTree.PrimMatrix.ValidateMatrix(System.Single[0:,0:])">
            <summary>
                Ensure that the given adjacency matrix represents a weighted undirected graph.
            </summary>
            <param name="adjacencyMatrix">Adjacency matric to check.</param>
        </member>
        <member name="M:Algorithms.Graph.MinimumSpanningTree.PrimMatrix.GetNextNode(System.Single[0:,0:],System.Single[],System.Boolean[],System.Int32[])">
            <summary>
                Determine which node should be added next to the MST.
            </summary>
            <param name="adjacencyMatrix">Adjacency matrix of graph.</param>
            <param name="key">Currently known minimum edge weight connected to each node.</param>
            <param name="added">Whether or not a node has been added to the MST.</param>
            <param name="parent">The node that added the node to the MST. Used for building MST adjacency matrix.</param>
        </member>
        <member name="T:Algorithms.Knapsack.BranchAndBoundKnapsackSolver`1">
            <summary>
                Branch and bound Knapsack solver.
            </summary>
            <typeparam name="T">Type of items in knapsack.</typeparam>
        </member>
        <member name="M:Algorithms.Knapsack.BranchAndBoundKnapsackSolver`1.Solve(`0[],System.Int32,System.Func{`0,System.Int32},System.Func{`0,System.Double})">
            <summary>
                Returns the knapsack containing the items that maximize value while not exceeding weight capacity.
                Construct a tree structure with total number of items + 1 levels, each node have two child nodes,
                starting with a dummy item root, each following levels are associated with 1 items, construct the
                tree in breadth first order to identify the optimal item set.
            </summary>
            <param name="items">All items to choose from.</param>
            <param name="capacity">The maximum weight capacity of the knapsack to be filled.</param>
            <param name="weightSelector">
                A function that returns the value of the specified item
                from the <paramref name="items">items</paramref> list.
            </param>
            <param name="valueSelector">
                A function that returns the weight of the specified item
                from the <paramref name="items">items</paramref> list.
            </param>
            <returns>
                The array of items that provides the maximum value of the
                knapsack without exceeding the specified weight <paramref name="capacity">capacity</paramref>.
            </returns>
        </member>
        <member name="M:Algorithms.Knapsack.BranchAndBoundKnapsackSolver`1.ComputeUpperBound(Algorithms.Knapsack.BranchAndBoundNode,`0[],System.Int32,System.Func{`0,System.Int32},System.Func{`0,System.Double})">
            <summary>
                Returns the upper bound value of a given node.
            </summary>
            <param name="aNode">The given node.</param>
            <param name="items">All items to choose from.</param>
            <param name="capacity">The maximum weight capacity of the knapsack to be filled.</param>
            <param name="weightSelector">
                A function that returns the value of the specified item
                from the <paramref name="items">items</paramref> list.
            </param>
            <param name="valueSelector">
                A function that returns the weight of the specified item
                from the <paramref name="items">items</paramref> list.
            </param>
            <returns>
                upper bound value of the given <paramref name="aNode">node</paramref>.
            </returns>
        </member>
        <member name="T:Algorithms.Knapsack.DynamicProgrammingKnapsackSolver`1">
            <summary>
                Dynamic Programming Knapsack solver.
            </summary>
            <typeparam name="T">Type of items in knapsack.</typeparam>
        </member>
        <member name="M:Algorithms.Knapsack.DynamicProgrammingKnapsackSolver`1.Solve(`0[],System.Int32,System.Func{`0,System.Int32},System.Func{`0,System.Double})">
            <summary>
                Returns the knapsack containing the items that
                maximize value while not exceeding weight capacity.
            </summary>
            <param name="items">The list of items from which we select ones to be in the knapsack.</param>
            <param name="capacity">
                The maximum weight capacity of the knapsack
                to be filled. Only integer values of this capacity are tried. If
                a greater resolution is needed, multiply the
                weights/capacity by a factor of 10.
            </param>
            <param name="weightSelector">
                A function that returns the value of the specified item
                from the <paramref name="items">items</paramref> list.
            </param>
            <param name="valueSelector">
                A function that returns the weight of the specified item
                from the <paramref name="items">items</paramref> list.
            </param>
            <returns>
                The array of items that provides the maximum value of the
                knapsack without exceeding the specified weight <paramref name="capacity">capacity</paramref>.
            </returns>
        </member>
        <member name="T:Algorithms.Knapsack.IHeuristicKnapsackSolver`1">
            <summary>
                Solves knapsack problem using some heuristics
                Sum of values of taken items -> max
                Sum of weights of taken items. &lt;= capacity.
            </summary>
            <typeparam name="T">Type of items in knapsack.</typeparam>
        </member>
        <member name="M:Algorithms.Knapsack.IHeuristicKnapsackSolver`1.Solve(`0[],System.Double,System.Func{`0,System.Double},System.Func{`0,System.Double})">
            <summary>
                Solves knapsack problem using some heuristics
                Sum of values of taken items -> max
                Sum of weights of taken items. &lt;= capacity.
            </summary>
            <param name="items">All items to choose from.</param>
            <param name="capacity">How much weight we can take.</param>
            <param name="weightSelector">Maps item to its weight.</param>
            <param name="valueSelector">Maps item to its value.</param>
            <returns>Items that were chosen.</returns>
        </member>
        <member name="T:Algorithms.Knapsack.IKnapsackSolver`1">
            <summary>
                Solves knapsack problem:
                to maximize sum of values of taken items,
                while sum of weights of taken items is less than capacity.
            </summary>
            <typeparam name="T">Type of items in knapsack.</typeparam>
        </member>
        <member name="T:Algorithms.Knapsack.NaiveKnapsackSolver`1">
            <summary>
                Greedy heurictic solver.
            </summary>
            <typeparam name="T">Type of items in knapsack.</typeparam>
        </member>
        <member name="M:Algorithms.Knapsack.NaiveKnapsackSolver`1.Solve(`0[],System.Double,System.Func{`0,System.Double},System.Func{`0,System.Double})">
            <summary>
                TODO.
            </summary>
            <param name="items">TODO. 2.</param>
            <param name="capacity">TODO. 3.</param>
            <param name="weightSelector">TODO. 4.</param>
            <param name="valueSelector">TODO. 5.</param>
            <returns>TODO. 6.</returns>
        </member>
        <member name="T:Algorithms.LinearAlgebra.Distances.Euclidean">
            <summary>
            Implementation for Euclidean distance.
            </summary>
        </member>
        <member name="M:Algorithms.LinearAlgebra.Distances.Euclidean.Distance(System.Double[],System.Double[])">
            <summary>
            Calculate Euclidean distance for two N-Dimensional points.
            </summary>
            <param name="point1">First N-Dimensional point.</param>
            <param name="point2">Second N-Dimensional point.</param>
            <returns>Calculated Euclidean distance.</returns>
        </member>
        <member name="T:Algorithms.LinearAlgebra.Distances.Manhattan">
             <summary>
             Implementation fo Manhattan distance.
             It is the sum of the lengths of the projections of the line segment between the points onto the coordinate axes.
             In other words, it is the sum of absolute difference between the measures in all dimensions of two points.
            
             Its commonly used in regression analysis.
             </summary>
        </member>
        <member name="M:Algorithms.LinearAlgebra.Distances.Manhattan.Distance(System.Double[],System.Double[])">
            <summary>
            Calculate Manhattan distance for two N-Dimensional points.
            </summary>
            <param name="point1">First N-Dimensional point.</param>
            <param name="point2">Second N-Dimensional point.</param>
            <returns>Calculated Manhattan distance.</returns>
        </member>
        <member name="T:Algorithms.LinearAlgebra.Eigenvalue.PowerIteration">
            <summary>
                Power iteration method - eigenvalue numeric algorithm, based on recurrent relation:
                Li+1 = (A * Li) / || A * Li ||, where Li - eigenvector approximation.
            </summary>
        </member>
        <member name="M:Algorithms.LinearAlgebra.Eigenvalue.PowerIteration.Dominant(System.Double[0:,0:],System.Double[],System.Double)">
            <summary>
                Returns approximation of the dominant eigenvalue and eigenvector of <paramref name="source" /> matrix.
            </summary>
            <list type="bullet">
                <item>
                    <description>The algorithm will not converge if the start vector is orthogonal to the eigenvector.</description>
                </item>
                <item>
                    <description>The <paramref name="source" /> matrix must be square-shaped.</description>
                </item>
            </list>
            <param name="source">Source square-shaped matrix.</param>
            <param name="startVector">Start vector.</param>
            <param name="error">Accuracy of the result.</param>
            <returns>Dominant eigenvalue and eigenvector pair.</returns>
            <exception cref="T:System.ArgumentException">The <paramref name="source" /> matrix is not square-shaped.</exception>
            <exception cref="T:System.ArgumentException">The length of the start vector doesn't equal the size of the source matrix.</exception>
        </member>
        <member name="M:Algorithms.LinearAlgebra.Eigenvalue.PowerIteration.Dominant(System.Double[0:,0:],System.Double)">
            <summary>
                Returns approximation of the dominant eigenvalue and eigenvector of <paramref name="source" /> matrix.
                Random normalized vector is used as the start vector to decrease chance of orthogonality to the eigenvector.
            </summary>
            <list type="bullet">
                <item>
                    <description>The algorithm will not converge if the start vector is orthogonal to the eigenvector.</description>
                </item>
                <item>
                    <description>The <paramref name="source" /> matrix should be square-shaped.</description>
                </item>
            </list>
            <param name="source">Source square-shaped matrix.</param>
            <param name="error">Accuracy of the result.</param>
            <returns>Dominant eigenvalue and eigenvector pair.</returns>
            <exception cref="T:System.ArgumentException">The <paramref name="source" /> matrix is not square-shaped.</exception>
            <exception cref="T:System.ArgumentException">The length of the start vector doesn't equal the size of the source matrix.</exception>
        </member>
        <member name="T:Algorithms.ModularArithmetic.ChineseRemainderTheorem">
            <summary>
            Chinese Remainder Theorem: https://en.wikipedia.org/wiki/Chinese_remainder_theorem.
            </summary>
        </member>
        <member name="M:Algorithms.ModularArithmetic.ChineseRemainderTheorem.Compute(System.Collections.Generic.List{System.Int64},System.Collections.Generic.List{System.Int64})">
            <summary>
                The Chinese Remainder Theorem is used to compute x for given set of pairs of integers (a_i, n_i) with:
                <list type="bullet">
                    <item>x = a_0 mod n_0</item>
                    <item>x = a_1 mod n_1</item>
                    <item>...</item>
                    <item>x = a_k mod n_k</item>
                </list>
                for 0 &lt;= i &lt; k, for some positive integer k. Additional requirements are:
                <list type="bullet">
                    <item>n_i > 1 for 0 &lt;= i &lt; k</item>
                    <item>n_i and n_j are coprime, for all 0 &lt;= i &lt; j &lt; k</item>
                    <item>0 &lt;= a_i &lt; n_i, for all 0 &lt;= i &lt; k</item>
                    <item>0 &lt;= x &lt; n_0 * n_1 * ... * n_(k-1)</item>
                </list>
            </summary>
            <param name="listOfAs">An ordered list of a_0, a_1, ..., a_k.</param>
            <param name="listOfNs">An ordered list of n_0, n_1, ..., n_k.</param>
            <returns>The value x.</returns>
            <exception cref="T:System.ArgumentException">If any of the requirements is not fulfilled.</exception>
        </member>
        <member name="M:Algorithms.ModularArithmetic.ChineseRemainderTheorem.Compute(System.Collections.Generic.List{System.Numerics.BigInteger},System.Collections.Generic.List{System.Numerics.BigInteger})">
            <summary>
                The Chinese Remainder Theorem is used to compute x for given set of pairs of integers (a_i, n_i) with:
                <list type="bullet">
                    <item>x = a_0 mod n_0</item>
                    <item>x = a_1 mod n_1</item>
                    <item>...</item>
                    <item>x = a_k mod n_k</item>
                </list>
                for 0 &lt;= i &lt; k, for some positive integer k. Additional requirements are:
                <list type="bullet">
                    <item>n_i > 1 for 0 &lt;= i &lt; k</item>
                    <item>n_i and n_j are coprime, for all 0 &lt;= i &lt; j &lt; k</item>
                    <item>0 &lt;= a_i &lt; n_i, for all 0 &lt;= i &lt; k</item>
                    <item>0 &lt;= x &lt; n_0 * n_1 * ... * n_(k-1)</item>
                </list>
            </summary>
            <param name="listOfAs">An ordered list of a_0, a_1, ..., a_k.</param>
            <param name="listOfNs">An ordered list of n_0, n_1, ..., n_k.</param>
            <returns>The value x.</returns>
            <exception cref="T:System.ArgumentException">If any of the requirements is not fulfilled.</exception>
        </member>
        <member name="M:Algorithms.ModularArithmetic.ChineseRemainderTheorem.CheckRequirements(System.Collections.Generic.List{System.Int64},System.Collections.Generic.List{System.Int64})">
            <summary>
            Checks the requirements for the algorithm and throws an ArgumentException if they are not being met.
            </summary>
            <param name="listOfAs">An ordered list of a_0, a_1, ..., a_k.</param>
            <param name="listOfNs">An ordered list of n_0, n_1, ..., n_k.</param>
            <exception cref="T:System.ArgumentException">If any of the requirements is not fulfilled.</exception>
        </member>
        <member name="M:Algorithms.ModularArithmetic.ChineseRemainderTheorem.CheckRequirements(System.Collections.Generic.List{System.Numerics.BigInteger},System.Collections.Generic.List{System.Numerics.BigInteger})">
            <summary>
            Checks the requirements for the algorithm and throws an ArgumentException if they are not being met.
            </summary>
            <param name="listOfAs">An ordered list of a_0, a_1, ..., a_k.</param>
            <param name="listOfNs">An ordered list of n_0, n_1, ..., n_k.</param>
            <exception cref="T:System.ArgumentException">If any of the requirements is not fulfilled.</exception>
        </member>
        <member name="T:Algorithms.ModularArithmetic.ExtendedEuclideanAlgorithm">
            <summary>
                Extended Euclidean algorithm: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
            </summary>
        </member>
        <member name="M:Algorithms.ModularArithmetic.ExtendedEuclideanAlgorithm.Compute(System.Int64,System.Int64)">
            <summary>
                Computes the greatest common divisor (gcd) of integers a and b, also the coefficients of Bézout's identity,
                which are integers x and y such that a*bezoutCoefficientOfA + b*bezoutCoefficientOfB = gcd(a, b).
            </summary>
            <param name="a">Input number.</param>
            <param name="b">Second input number.</param>
            <returns>A record of ExtendedEuclideanAlgorithmResult containing the bezout coefficients of a and b as well as the gcd(a,b).</returns>
        </member>
        <member name="M:Algorithms.ModularArithmetic.ExtendedEuclideanAlgorithm.Compute(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
                Computes the greatest common divisor (gcd) of integers a and b, also the coefficients of Bézout's identity,
                which are integers x and y such that a*bezoutCoefficientOfA + b*bezoutCoefficientOfB = gcd(a, b).
            </summary>
            <param name="a">Input number.</param>
            <param name="b">Second input number.</param>
            <returns>A record of ExtendedEuclideanAlgorithmResult containing the bezout coefficients of a and b as well as the gcd(a,b).</returns>
        </member>
        <member name="T:Algorithms.ModularArithmetic.ExtendedEuclideanAlgorithm.ExtendedEuclideanAlgorithmResult`1">
            <summary>
            The result type for the computation of the Extended Euclidean Algorithm.
            </summary>
            <typeparam name="T">The data type of the computation (i.e. long or BigInteger).</typeparam>
            <param name="bezoutA">The bezout coefficient of the parameter a to the computation.</param>
            <param name="bezoutB">The bezout coefficient of the parameter b to the computation.</param>
            <param name="gcd">The greatest common divisor of the parameters a and b to the computation.</param>
        </member>
        <member name="M:Algorithms.ModularArithmetic.ExtendedEuclideanAlgorithm.ExtendedEuclideanAlgorithmResult`1.#ctor(`0,`0,`0)">
            <summary>
            The result type for the computation of the Extended Euclidean Algorithm.
            </summary>
            <typeparam name="T">The data type of the computation (i.e. long or BigInteger).</typeparam>
            <param name="bezoutA">The bezout coefficient of the parameter a to the computation.</param>
            <param name="bezoutB">The bezout coefficient of the parameter b to the computation.</param>
            <param name="gcd">The greatest common divisor of the parameters a and b to the computation.</param>
        </member>
        <member name="P:Algorithms.ModularArithmetic.ExtendedEuclideanAlgorithm.ExtendedEuclideanAlgorithmResult`1.bezoutA">
            <summary>The bezout coefficient of the parameter a to the computation.</summary>
        </member>
        <member name="P:Algorithms.ModularArithmetic.ExtendedEuclideanAlgorithm.ExtendedEuclideanAlgorithmResult`1.bezoutB">
            <summary>The bezout coefficient of the parameter b to the computation.</summary>
        </member>
        <member name="P:Algorithms.ModularArithmetic.ExtendedEuclideanAlgorithm.ExtendedEuclideanAlgorithmResult`1.gcd">
            <summary>The greatest common divisor of the parameters a and b to the computation.</summary>
        </member>
        <member name="T:Algorithms.ModularArithmetic.ModularMultiplicativeInverse">
            <summary>
            Modular multiplicative inverse: https://en.wikipedia.org/wiki/Modular_multiplicative_inverse.
            </summary>
        </member>
        <member name="M:Algorithms.ModularArithmetic.ModularMultiplicativeInverse.Compute(System.Int64,System.Int64)">
            <summary>
                Computes the modular multiplicative inverse of a in Z/nZ, if there is any (i.e. if a and n are coprime).
            </summary>
            <param name="a">The number a, of which to compute the multiplicative inverse.</param>
            <param name="n">The modulus n.</param>
            <returns>The multiplicative inverse of a in Z/nZ, a value in the interval [0, n).</returns>
            <exception cref="T:System.ArithmeticException">If there exists no multiplicative inverse of a in Z/nZ.</exception>
        </member>
        <member name="M:Algorithms.ModularArithmetic.ModularMultiplicativeInverse.Compute(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
                Computes the modular multiplicative inverse of a in Z/nZ, if there is any (i.e. if a and n are coprime).
            </summary>
            <param name="a">The number a, of which to compute the multiplicative inverse.</param>
            <param name="n">The modulus n.</param>
            <returns>The multiplicative inverse of a in Z/nZ, a value in the interval [0, n).</returns>
            <exception cref="T:System.ArithmeticException">If there exists no multiplicative inverse of a in Z/nZ.</exception>
        </member>
        <member name="T:Algorithms.Numeric.AliquotSumCalculator">
            <summary>
                In number theory, the aliquot sum s(n) of a positive integer n is the sum of all proper divisors
                of n, that is, all divisors of n other than n itself. For example, the proper divisors of 15
                (that is, the positive divisors of 15 that are not equal to 15) are 1, 3 and 5, so the aliquot
                sum of 15 is 9 i.e. (1 + 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.AliquotSumCalculator.CalculateAliquotSum(System.Int32)">
            <summary>
                Finds the aliquot sum of an integer number.
            </summary>
            <param name="number">Positive number.</param>
            <returns>The Aliquot Sum.</returns>
            <exception cref="T:System.ArgumentException">Error number is not on interval (0.0; int.MaxValue).</exception>
        </member>
        <member name="T:Algorithms.Numeric.AmicableNumbersChecker">
            <summary>
            Amicable numbers are two different natural numbers related in such a way that the sum of the proper divisors of
            each is equal to the other number. That is, σ(a)=b+a and σ(b)=a+b, where σ(n) is equal to the sum of positive divisors of n (see also divisor function).
            See <a href="https://en.wikipedia.org/wiki/Amicable_numbers">here</a> for more info.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.AmicableNumbersChecker.AreAmicableNumbers(System.Int32,System.Int32)">
            <summary>
            Checks if two numbers are amicable or not.
            </summary>
            <param name="x">First number to check.</param>
            <param name="y">Second number to check.</param>
            <returns>True if they are amicable numbers. False if not.</returns>
        </member>
        <member name="T:Algorithms.Numeric.AutomorphicNumber">
            <summary>
            Calculates Automorphic numbers. A number is said to be an Automorphic number
            if the square of the number will contain the number itself at the end.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.AutomorphicNumber.GetAutomorphicNumbers(System.Int32,System.Int32)">
            <summary>
            Generates a list of automorphic numbers that are between <paramref name="lowerBound"/> and <paramref name="upperBound"/>
            inclusive.
            </summary>
            <param name="lowerBound">The lower bound of the list.</param>
            <param name="upperBound">The upper bound of the list.</param>
            <returns>A list that contains all of the automorphic numbers between <paramref name="lowerBound"/> and <paramref name="upperBound"/> inclusive.</returns>
            <exception cref="T:System.ArgumentException">If the <paramref name="lowerBound"/>
            or <paramref name="upperBound"/> is not greater than zero
            or <paramref name="upperBound"/>is lower than the <paramref name="lowerBound"/>.</exception>
        </member>
        <member name="M:Algorithms.Numeric.AutomorphicNumber.IsAutomorphic(System.Int32)">
            <summary>
            Checks if a given natural number is automorphic or not.
            </summary>
            <param name="number">The number to check.</param>
            <returns>True if the number is automorphic, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">If the number is non-positive.</exception>
        </member>
        <member name="T:Algorithms.Numeric.BinomialCoefficient">
            <summary>
                The binomial coefficients are the positive integers
                that occur as coefficients in the binomial theorem.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.BinomialCoefficient.Calculate(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
                Calculates Binomial coefficients for given input.
            </summary>
            <param name="num">First number.</param>
            <param name="k">Second number.</param>
            <returns>Binimial Coefficients.</returns>
        </member>
        <member name="T:Algorithms.Numeric.Decomposition.Lu">
            <summary>
                LU-decomposition factors the "source" matrix as the product of lower triangular matrix
                and upper triangular matrix.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.Decomposition.Lu.Decompose(System.Double[0:,0:])">
            <summary>
                Performs LU-decomposition on "source" matrix.
                Lower and upper matrices have same shapes as source matrix.
                Note: Decomposition can be applied only to square matrices.
            </summary>
            <param name="source">Square matrix to decompose.</param>
            <returns>Tuple of lower and upper matrix.</returns>
            <exception cref="T:System.ArgumentException">Source matrix is not square shaped.</exception>
        </member>
        <member name="M:Algorithms.Numeric.Decomposition.Lu.Eliminate(System.Double[0:,0:],System.Double[])">
            <summary>
                Eliminates linear equations system represented as A*x=b, using LU-decomposition,
                where A - matrix of equation coefficients, b - vector of absolute terms of equations.
            </summary>
            <param name="matrix">Matrix of equation coefficients.</param>
            <param name="coefficients">Vector of absolute terms of equations.</param>
            <returns>Vector-solution for linear equations system.</returns>
            <exception cref="T:System.ArgumentException">Matrix of equation coefficients is not square shaped.</exception>
        </member>
        <member name="T:Algorithms.Numeric.Decomposition.ThinSvd">
            <summary>
                Singular Vector Decomposition decomposes any general matrix into its
                singular values and a set of orthonormal bases.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.Decomposition.ThinSvd.RandomUnitVector(System.Int32)">
            <summary>
                Computes a random unit vector.
            </summary>
            <param name="dimensions">The dimensions of the required vector.</param>
            <returns>The unit vector.</returns>
        </member>
        <member name="M:Algorithms.Numeric.Decomposition.ThinSvd.Decompose1D(System.Double[0:,0:])">
            <summary>
                Computes a single singular vector for the given matrix, corresponding to the largest singular value.
            </summary>
            <param name="matrix">The matrix.</param>
            <returns>A singular vector, with dimension equal to number of columns of the matrix.</returns>
        </member>
        <member name="M:Algorithms.Numeric.Decomposition.ThinSvd.Decompose1D(System.Double[0:,0:],System.Double,System.Int32)">
            <summary>
                Computes a single singular vector for the given matrix, corresponding to the largest singular value.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="epsilon">The error margin.</param>
            <param name="maxIterations">The maximum number of iterations.</param>
            <returns>A singular vector, with dimension equal to number of columns of the matrix.</returns>
        </member>
        <member name="M:Algorithms.Numeric.Decomposition.ThinSvd.Decompose(System.Double[0:,0:],System.Double,System.Int32)">
            <summary>
                Computes the SVD for the given matrix, with singular values arranged from greatest to least.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="epsilon">The error margin.</param>
            <param name="maxIterations">The maximum number of iterations.</param>
            <returns>The SVD.</returns>
        </member>
        <member name="T:Algorithms.Numeric.EulerMethod">
            <summary>
                In mathematics and computational science, the Euler method (also called forward Euler method)
                is a first-order numerical procedure for solving ordinary differential equations (ODEs)
                with a given initial value (aka. Cauchy problem). It is the most basic explicit method for numerical integration
                of ordinary differential equations. The method proceeds in a series of steps. At each step
                the y-value is calculated by evaluating the differential equation at the previous step,
                multiplying the result with the step-size and adding it to the last y-value:
                y_n+1 = y_n + stepSize * f(x_n, y_n).
                (description adapted from https://en.wikipedia.org/wiki/Euler_method )
                (see also: https://www.geeksforgeeks.org/euler-method-solving-differential-equation/ ).
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.EulerMethod.EulerFull(System.Double,System.Double,System.Double,System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
                Loops through all the steps until xEnd is reached, adds a point for each step and then
                returns all the points.
            </summary>
            <param name="xStart">Initial conditions x-value.</param>
            <param name="xEnd">Last x-value.</param>
            <param name="stepSize">Step-size on the x-axis.</param>
            <param name="yStart">Initial conditions y-value.</param>
            <param name="yDerivative">The right hand side of the differential equation.</param>
            <returns>The solution of the Cauchy problem.</returns>
        </member>
        <member name="M:Algorithms.Numeric.EulerMethod.EulerStep(System.Double,System.Double,System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
                Calculates the next y-value based on the current value of x, y and the stepSize.
            </summary>
            <param name="xCurrent">Current x-value.</param>
            <param name="stepSize">Step-size on the x-axis.</param>
            <param name="yCurrent">Current y-value.</param>
            <param name="yDerivative">The right hand side of the differential equation.</param>
            <returns>The next y-value.</returns>
        </member>
        <member name="T:Algorithms.Numeric.Factorial">
            <summary>
                The factorial of a positive integer n, denoted by n!,
                is the product of all positive integers less than or equal to n.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.Factorial.Calculate(System.Int32)">
            <summary>
                Calculates factorial of a integer number.
            </summary>
            <param name="inputNum">Integer Input number.</param>
            <returns>Factorial of integer input number.</returns>
        </member>
        <member name="T:Algorithms.Numeric.Factorization.IFactorizer">
            <summary>
                Finds a factor of a given number or returns false if it's prime.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.Factorization.IFactorizer.TryFactor(System.Int32,System.Int32@)">
            <summary>
                Finds a factor of a given number or returns false if it's prime.
            </summary>
            <param name="n">Integer to factor.</param>
            <param name="factor">Found factor.</param>
            <returns><see langword="true" /> if factor is found, <see langword="false" /> if <paramref name="n" /> is prime.</returns>
        </member>
        <member name="T:Algorithms.Numeric.Factorization.TrialDivisionFactorizer">
            <summary>
                Factors number using trial division algorithm.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.Factorization.TrialDivisionFactorizer.TryFactor(System.Int32,System.Int32@)">
            <summary>
                Finds the smallest non trivial factor (i.e.: 1 &lt; factor &lt;= sqrt(<paramref name="n" />)) of a given number or returns false if it's prime.
            </summary>
            <param name="n">Integer to factor.</param>
            <param name="factor">Found factor.</param>
            <returns><see langword="true" /> if factor is found, <see langword="false" /> if <paramref name="n" /> is prime.</returns>
        </member>
        <member name="T:Algorithms.Numeric.GaussJordanElimination">
            <summary>
                Algorithm used to find the inverse of any matrix that can be inverted.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.GaussJordanElimination.Solve(System.Double[0:,0:])">
            <summary>
                Method to find a linear equation system using gaussian elimination.
            </summary>
            <param name="matrix">The key matrix to solve via algorithm.</param>
            <returns>
                whether the input matrix has a unique solution or not.
                and solves on the given matrix.
            </returns>
        </member>
        <member name="M:Algorithms.Numeric.GaussJordanElimination.CanMatrixBeUsed(System.Double[0:,0:])">
            <summary>
                To make simple validation of the matrix to be used.
            </summary>
            <param name="matrix">Multidimensional array matrix.</param>
            <returns>
                True: if algorithm can be use for given matrix;
                False: Otherwise.
            </returns>
        </member>
        <member name="M:Algorithms.Numeric.GaussJordanElimination.PivotMatrix(System.Double[0:,0:]@)">
            <summary>
                To prepare given matrix by pivoting rows.
            </summary>
            <param name="matrix">Input matrix.</param>
            <returns>Matrix.</returns>
        </member>
        <member name="M:Algorithms.Numeric.GaussJordanElimination.Elimination(System.Double[0:,0:]@)">
            <summary>
                Applies REF.
            </summary>
            <param name="matrix">Input matrix.</param>
        </member>
        <member name="M:Algorithms.Numeric.GaussJordanElimination.ElementaryReduction(System.Double[0:,0:]@)">
            <summary>
                To continue reducing the matrix using RREF.
            </summary>
            <param name="matrix">Input matrix.</param>
            <returns>True if it has a unique solution; false otherwise.</returns>
        </member>
        <member name="T:Algorithms.Numeric.GreatestCommonDivisor.BinaryGreatestCommonDivisorFinder">
            <summary>
                Finds greatest common divisor for numbers u and v
                using binary algorithm.
                Wiki: https://en.wikipedia.org/wiki/Binary_GCD_algorithm.
            </summary>
        </member>
        <member name="T:Algorithms.Numeric.GreatestCommonDivisor.EuclideanGreatestCommonDivisorFinder">
            <summary>
                TODO.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.GreatestCommonDivisor.EuclideanGreatestCommonDivisorFinder.FindGcd(System.Int32,System.Int32)">
            <summary>
                Finds greatest common divisor for numbers a and b
                using euclidean algorithm.
            </summary>
            <param name="a">TODO.</param>
            <param name="b">TODO. 2.</param>
            <returns>Greatest common divisor.</returns>
        </member>
        <member name="M:Algorithms.Numeric.JosephusProblem.FindWinner(System.Int64,System.Int64)">
            <summary>
            Calculates the winner in the Josephus problem.
            </summary>
            <param name="n">The number of people in the initial circle.</param>
            <param name="k">The count of each step. k-1 people are skipped and the k-th is executed.</param>
            <returns>The 1-indexed position where the player must choose in order to win the game.</returns>
        </member>
        <member name="T:Algorithms.Numeric.KeithNumberChecker">
            <summary>
             In number theory, a Keith number or repfigit number is a natural number n in a given number base b with k digits such that
             when a sequence is created such that the first k terms are the k digits of n and each subsequent term is the sum of the
             previous k terms, n is part of the sequence.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.KeithNumberChecker.IsKeithNumber(System.Int32)">
            <summary>
                Checks if a number is a Keith number or not.
            </summary>
            <param name="number">Number to check.</param>
            <returns>True if it is a Keith number; False otherwise.</returns>
        </member>
        <member name="T:Algorithms.Numeric.KrishnamurthyNumberChecker">
             <summary>
             A Krishnamurthy number is a number whose sum of the factorial of digits
             is equal to the number itself.
            
             For example, 145 is a Krishnamurthy number since: 1! + 4! + 5! = 1 + 24 + 120 = 145.
             </summary>
        </member>
        <member name="M:Algorithms.Numeric.KrishnamurthyNumberChecker.IsKMurthyNumber(System.Int32)">
            <summary>
            Check if a number is Krishnamurthy number or not.
            </summary>
            <param name="n">The number to check.</param>
            <returns>True if the number is Krishnamurthy, false otherwise.</returns>
        </member>
        <member name="T:Algorithms.Numeric.MillerRabinPrimalityChecker">
            <summary>
            https://en.wikipedia.org/wiki/Miller-Rabin_primality_test
            The Miller–Rabin primality test or Rabin–Miller primality test is a probabilistic primality test:
            an algorithm which determines whether a given number is likely to be prime,
            similar to the Fermat primality test and the Solovay–Strassen primality test.
            It is of historical significance in the search for a polynomial-time deterministic primality test.
            Its probabilistic variant remains widely used in practice, as one of the simplest and fastest tests known.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.MillerRabinPrimalityChecker.IsProbablyPrimeNumber(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Nullable{System.Int32})">
            <summary>
                Run the probabilistic primality test.
                </summary>
            <param name="n">Number to check.</param>
            <param name="rounds">Number of rounds, the parameter determines the accuracy of the test, recommended value is Log2(n).</param>
            <param name="seed">Seed for random number generator.</param>
            <returns>True if is a highly likely prime number; False otherwise.</returns>
            <exception cref="T:System.ArgumentException">Error: number should be more than 3.</exception>
        </member>
        <member name="T:Algorithms.Numeric.ModularExponentiation">
            <summary>
                Modular exponentiation is a type of exponentiation performed over a modulus
                Modular exponentiation c is: c = b^e mod m where b is base, e is exponent, m is modulus
                (Wiki: https://en.wikipedia.org/wiki/Modular_exponentiation).
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.ModularExponentiation.ModularPow(System.Int32,System.Int32,System.Int32)">
            <summary>
                Performs Modular Exponentiation on b, e, m.
            </summary>
            <param name="b">Base.</param>
            <param name="e">Exponent.</param>
            <param name="m">Modulus.</param>
            <returns>Modular Exponential.</returns>
        </member>
        <member name="T:Algorithms.Numeric.NarcissisticNumberChecker">
            <summary>
                A Narcissistic number is equal to the sum of the cubes of its digits. For example, 370 is a
                Narcissistic number because 3*3*3 + 7*7*7 + 0*0*0 = 370.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.NarcissisticNumberChecker.IsNarcissistic(System.Int32)">
            <summary>
                Checks if a number is a Narcissistic number or not.
            </summary>
            <param name="number">Number to check.</param>
            <returns>True if is a Narcissistic number; False otherwise.</returns>
        </member>
        <member name="T:Algorithms.Numeric.PerfectNumberChecker">
            <summary>
                In number theory, a perfect number is a positive integer that is equal to the sum of its positive
                divisors, excluding the number itself.For instance, 6 has divisors 1, 2 and 3 (excluding
                itself), and 1 + 2 + 3 = 6, so 6 is a perfect number.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.PerfectNumberChecker.IsPerfectNumber(System.Int32)">
            <summary>
                Checks if a number is a perfect number or not.
            </summary>
            <param name="number">Number to check.</param>
            <returns>True if is a perfect number; False otherwise.</returns>
            <exception cref="T:System.ArgumentException">Error number is not on interval (0.0; int.MaxValue).</exception>
        </member>
        <member name="T:Algorithms.Numeric.PerfectSquareChecker">
            <summary>
                A perfect square is an element of algebraic structure that is equal to the square of another element.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.PerfectSquareChecker.IsPerfectSquare(System.Int32)">
            <summary>
                Checks if a number is a perfect square or not.
            </summary>
            <param name="number">Number too check.</param>
            <returns>True if is a perfect square; False otherwise.</returns>
        </member>
        <member name="T:Algorithms.Numeric.Pseudoinverse.PseudoInverse">
            <summary>
                The Moore–Penrose pseudo-inverse A+ of a matrix A,
                is a general way to find the solution to the following system of linear equations:
                ~b = A ~y. ~b e R^m; ~y e R^n; A e Rm×n.
                There are varios methods for construction the pseudo-inverse.
                This one is based on Singular Value Decomposition (SVD).
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.Pseudoinverse.PseudoInverse.PInv(System.Double[0:,0:])">
            <summary>
                Return the pseudoinverse of a matrix based on the Moore-Penrose Algorithm.
                using Singular Value Decomposition (SVD).
            </summary>
            <param name="inMat">Input matrix to find its inverse to.</param>
            <returns>The inverse matrix approximation of the input matrix.</returns>
        </member>
        <member name="T:Algorithms.Numeric.RungeKuttaMethod">
            <summary>
                In numerical analysis, the Runge–Kutta methods are a family of implicit and explicit iterative methods,
                used in temporal discretization for the approximate solutions of simultaneous nonlinear equations.
                The most widely known member of the Runge–Kutta family is generally referred to as
                "RK4", the "classic Runge–Kutta method" or simply as "the Runge–Kutta method".
                </summary>
        </member>
        <member name="M:Algorithms.Numeric.RungeKuttaMethod.ClassicRungeKuttaMethod(System.Double,System.Double,System.Double,System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
                Loops through all the steps until xEnd is reached, adds a point for each step and then
                returns all the points.
            </summary>
            <param name="xStart">Initial conditions x-value.</param>
            <param name="xEnd">Last x-value.</param>
            <param name="stepSize">Step-size on the x-axis.</param>
            <param name="yStart">Initial conditions y-value.</param>
            <param name="function">The right hand side of the differential equation.</param>
            <returns>The solution of the Cauchy problem.</returns>
        </member>
        <member name="T:Algorithms.Numeric.Series.Maclaurin">
            <summary>
                Maclaurin series calculates nonlinear functions approximation
                starting from point x = 0 in a form of infinite power series:
                f(x) = f(0) + f'(0) * x + ... + (f'n(0) * (x ^ n)) / n! + ...,
                where n is natural number.
            </summary>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.Exp(System.Double,System.Int32)">
            <summary>
                Calculates approximation of e^x function:
                e^x = 1 + x + x^2 / 2! + ... + x^n / n! + ...,
                where n is number of terms (natural number),
                and x is given point (rational number).
            </summary>
            <param name="x">Given point.</param>
            <param name="n">The number of terms in polynomial.</param>
            <returns>Approximated value of the function in the given point.</returns>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.Sin(System.Double,System.Int32)">
            <summary>
                Calculates approximation of sin(x) function:
                sin(x) = x - x^3 / 3! + ... + (-1)^n * x^(2*n + 1) / (2*n + 1)! + ...,
                where n is number of terms (natural number),
                and x is given point (rational number).
            </summary>
            <param name="x">Given point.</param>
            <param name="n">The number of terms in polynomial.</param>
            <returns>Approximated value of the function in the given point.</returns>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.Cos(System.Double,System.Int32)">
            <summary>
                Calculates approximation of cos(x) function:
                cos(x) = 1 - x^2 / 2! + ... + (-1)^n * x^(2*n) / (2*n)! + ...,
                where n is number of terms (natural number),
                and x is given point (rational number).
            </summary>
            <param name="x">Given point.</param>
            <param name="n">The number of terms in polynomial.</param>
            <returns>Approximated value of the function in the given point.</returns>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.Exp(System.Double,System.Double)">
            <summary>
                Calculates approximation of e^x function:
                e^x = 1 + x + x^2 / 2! + ... + x^n / n! + ...,
                and x is given point (rational number).
            </summary>
            <param name="x">Given point.</param>
            <param name="error">Last term error value.</param>
            <returns>Approximated value of the function in the given point.</returns>
            <exception cref="T:System.ArgumentException">Error value is not on interval (0.0; 1.0).</exception>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.Sin(System.Double,System.Double)">
            <summary>
                Calculates approximation of sin(x) function:
                sin(x) = x - x^3 / 3! + ... + (-1)^n * x^(2*n + 1) / (2*n + 1)! + ...,
                and x is given point (rational number).
            </summary>
            <param name="x">Given point.</param>
            <param name="error">Last term error value.</param>
            <returns>Approximated value of the function in the given point.</returns>
            <exception cref="T:System.ArgumentException">Error value is not on interval (0.0; 1.0).</exception>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.Cos(System.Double,System.Double)">
            <summary>
                Calculates approximation of cos(x) function:
                cos(x) = 1 - x^2 / 2! + ... + (-1)^n * x^(2*n) / (2*n)! + ...,
                and x is given point (rational number).
            </summary>
            <param name="x">Given point.</param>
            <param name="error">Last term error value.</param>
            <returns>Approximated value of the function in the given point.</returns>
            <exception cref="T:System.ArgumentException">Error value is not on interval (0.0; 1.0).</exception>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.ErrorTermWrapper(System.Double,System.Double,System.Func{System.Double,System.Int32,System.Double})">
            <summary>
                Wrapper function for calculating approximation with estimated
                count of terms, where last term value is less than given error.
            </summary>
            <param name="x">Given point.</param>
            <param name="error">Last term error value.</param>
            <param name="term">Indexed term of approximation series.</param>
            <returns>Approximated value of the function in the given point.</returns>
            <exception cref="T:System.ArgumentException">Error value is not on interval (0.0; 1.0).</exception>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.ExpTerm(System.Double,System.Int32)">
            <summary>
                Single term for e^x function approximation: x^i / i!.
            </summary>
            <param name="x">Given point.</param>
            <param name="i">Term index from 0 to n.</param>
            <returns>Single term value.</returns>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.SinTerm(System.Double,System.Int32)">
            <summary>
                Single term for sin(x) function approximation: (-1)^i * x^(2*i + 1) / (2*i + 1)!.
            </summary>
            <param name="x">Given point.</param>
            <param name="i">Term index from 0 to n.</param>
            <returns>Single term value.</returns>
        </member>
        <member name="M:Algorithms.Numeric.Series.Maclaurin.CosTerm(System.Double,System.Int32)">
            <summary>
                Single term for cos(x) function approximation: (-1)^i * x^(2*i) / (2*i)!.
            </summary>
            <param name="x">Given point.</param>
            <param name="i">Term index from 0 to n.</param>
            <returns>Single term value.</returns>
        </member>
        <member name="T:Algorithms.Other.DecisionsConvolutions">
            <summary>
            Almost all real complex decision-making task is described by more than one criterion.
            There are different methods to select the best decisions from the defined set of decisions.
            This class contains implementations of the popular convolution methods: linear and maxmin.
            </summary>
        </member>
        <member name="M:Algorithms.Other.DecisionsConvolutions.Linear(System.Collections.Generic.List{System.Collections.Generic.List{System.Decimal}},System.Collections.Generic.List{System.Decimal})">
            <summary>
            This method implements the linear method of decision selection. It is based on
            the calculation of the "value" for each decision and the selection of the most
            valuable one.
            </summary>
            <param name="matrix">Contains a collection of the criteria sets.</param>
            <param name="priorities">Contains a set of priorities for each criterion.</param>
            <returns>The most effective decision that is represented by a set of criterias.</returns>
        </member>
        <member name="M:Algorithms.Other.DecisionsConvolutions.MaxMin(System.Collections.Generic.List{System.Collections.Generic.List{System.Decimal}},System.Collections.Generic.List{System.Decimal})">
            <summary>
            This method implements maxmin method of the decision selection. It is based on
            the calculation of the least criteria value and comparison of decisions based
            on the calculated results.
            </summary>
            <param name="matrix">Contains a collection of the criteria sets.</param>
            <param name="priorities">Contains a set of priorities for each criterion.</param>
            <returns>The most effective decision that is represented by a set of criterias.</returns>
        </member>
        <member name="T:Algorithms.Other.FermatPrimeChecker">
            <summary>
                Fermat's prime tester https://en.wikipedia.org/wiki/Fermat_primality_test.
            </summary>
        </member>
        <member name="M:Algorithms.Other.FermatPrimeChecker.IsPrime(System.Int32,System.Int32)">
            <summary>
                Checks if input number is a probable prime.
            </summary>
            <param name="numberToTest">Input number.</param>
            <param name="timesToCheck">Number of times to check.</param>
            <returns>True if is a prime; False otherwise.</returns>
        </member>
        <member name="T:Algorithms.Other.FloodFill">
            <summary>
            Flood fill, also called seed fill, is an algorithm that determines and
            alters the area connected to a given node in a multi-dimensional array with
            some matching attribute. It is used in the "bucket" fill tool of paint
            programs to fill connected, similarly-colored areas with a different color.
            (description adapted from https://en.wikipedia.org/wiki/Flood_fill)
            (see also: https://www.techiedelight.com/flood-fill-algorithm/).
            </summary>
        </member>
        <member name="M:Algorithms.Other.FloodFill.BreadthFirstSearch(System.Drawing.Bitmap,System.ValueTuple{System.Int32,System.Int32},System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Implements the flood fill algorithm through a breadth-first approach using a queue.
            </summary>
            <param name="bitmap">The bitmap to which the algorithm is applied.</param>
            <param name="location">The start location on the bitmap.</param>
            <param name="targetColor">The old color to be replaced.</param>
            <param name="replacementColor">The new color to replace the old one.</param>
        </member>
        <member name="M:Algorithms.Other.FloodFill.DepthFirstSearch(System.Drawing.Bitmap,System.ValueTuple{System.Int32,System.Int32},System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Implements the flood fill algorithm through a depth-first approach through recursion.
            </summary>
            <param name="bitmap">The bitmap to which the algorithm is applied.</param>
            <param name="location">The start location on the bitmap.</param>
            <param name="targetColor">The old color to be replaced.</param>
            <param name="replacementColor">The new color to replace the old one.</param>
        </member>
        <member name="T:Algorithms.Other.GaussOptimization">
            <summary>
            The Gaussian method (coordinate descent method) refers to zero-order methods in which only the value
            of the function Q(X) at different points in the space of variables is used to organize the search
            for the extremum. This reduces the overall computational cost of finding the extremum. Also in
            the Gaussian method, the procedures for finding and moving the operating point are simplified as
            much as possible.
            </summary>
        </member>
        <member name="M:Algorithms.Other.GaussOptimization.Optimize(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Implementation of function extremum search by the Gauss optimization algorithm.
            </summary>
            <param name="func">Function for which extremum has to be found.</param>
            <param name="n">This parameter identifies how much step size will be decreased each iteration.</param>
            <param name="step">The initial shift step.</param>
            <param name="eps">This value is used to control the accuracy of the optimization. In case if the error is less than eps,
            optimization will be stopped.</param>
            <param name="x1">The first function parameter.</param>
            <param name="x2">The second function parameter.</param>
            <returns>A tuple of coordinates of function extremum.</returns>
        </member>
        <member name="M:Algorithms.Other.GeoLocation.CalculateDistanceFromLatLng(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                Calculates spherical distance between 2 points given their latitude, longitude coordinates.
                https://www.movable-type.co.uk/scripts/latlong.html.
            </summary>
            <param name="lat1">Latitude of point A.</param>
            <param name="lng1">Longitude of point A.</param>
            <param name="lat2">Latitude of point B.</param>
            <param name="lng2">Longitude of point B.</param>
            <returns>Spherical distance between A and B.</returns>
        </member>
        <member name="T:Algorithms.Other.Int2Binary">
            <summary>
                Manually converts an integer of certain size to a string of the binary representation.
            </summary>
        </member>
        <member name="M:Algorithms.Other.Int2Binary.Int2Bin(System.UInt16)">
            <summary>
                Returns string of the binary representation of given Int.
            </summary>
            <param name="input">Number to be converted.</param>
            <returns>Binary representation of input.</returns>
        </member>
        <member name="M:Algorithms.Other.Int2Binary.Int2Bin(System.UInt32)">
            <summary>
                Returns string of the binary representation of given Int.
            </summary>
            <param name="input">Number to be converted.</param>
            <returns>Binary representation of input.</returns>
        </member>
        <member name="M:Algorithms.Other.Int2Binary.Int2Bin(System.UInt64)">
            <summary>
                Returns string of the binary representation of given Int.
            </summary>
            <param name="input">Number to be converted.</param>
            <returns>Binary representation of input.</returns>
        </member>
        <member name="T:Algorithms.Other.JulianEaster">
            <summary>
                Date of Easter calculated with Meeus's Julian algorithm.
                The algorithm is described in Jean Meeus' <a href="https://archive.org/details/astronomicalalgorithmsjeanmeeus1991/page/n73/mode/2up">Astronomical Algorithms (1991, p. 69)</a>.
            </summary>
        </member>
        <member name="M:Algorithms.Other.JulianEaster.Calculate(System.Int32)">
            <summary>
                Calculates the date of Easter.
            </summary>
            <param name="year">Year to calculate the date of Easter.</param>
            <returns>Date of Easter as a DateTime.</returns>
        </member>
        <member name="T:Algorithms.Other.KochSnowflake">
            <summary>
                The Koch snowflake is a fractal curve and one of the earliest fractals to
                have been described. The Koch snowflake can be built up iteratively, in a
                sequence of stages. The first stage is an equilateral triangle, and each
                successive stage is formed by adding outward bends to each side of the
                previous stage, making smaller equilateral triangles.
                This can be achieved through the following steps for each line:
                1. divide the line segment into three segments of equal length.
                2. draw an equilateral triangle that has the middle segment from step 1
                as its base and points outward.
                3. remove the line segment that is the base of the triangle from step 2.
                (description adapted from https://en.wikipedia.org/wiki/Koch_snowflake )
                (for a more detailed explanation and an implementation in the
                Processing language, see  https://natureofcode.com/book/chapter-8-fractals/
                #84-the-koch-curve-and-the-arraylist-technique ).
            </summary>
        </member>
        <member name="M:Algorithms.Other.KochSnowflake.Iterate(System.Collections.Generic.List{System.Numerics.Vector2},System.Int32)">
            <summary>
                Go through the number of iterations determined by the argument "steps".
                Be careful with high values (above 5) since the time to calculate increases
                exponentially.
            </summary>
            <param name="initialVectors">
                The vectors composing the shape to which
                the algorithm is applied.
            </param>
            <param name="steps">The number of iterations.</param>
            <returns>The transformed vectors after the iteration-steps.</returns>
        </member>
        <member name="M:Algorithms.Other.KochSnowflake.GetKochSnowflake(System.Int32,System.Int32)">
            <summary>
                Method to render the Koch snowflake to a bitmap. To save the
                bitmap the command 'GetKochSnowflake().Save("KochSnowflake.png")' can be used.
            </summary>
            <param name="bitmapWidth">The width of the rendered bitmap.</param>
            <param name="steps">The number of iterations.</param>
            <returns>The bitmap of the rendered Koch snowflake.</returns>
        </member>
        <member name="M:Algorithms.Other.KochSnowflake.IterationStep(System.Collections.Generic.List{System.Numerics.Vector2})">
            <summary>
                Loops through each pair of adjacent vectors. Each line between two adjacent
                vectors is divided into 4 segments by adding 3 additional vectors in-between
                the original two vectors. The vector in the middle is constructed through a
                60 degree rotation so it is bent outwards.
            </summary>
            <param name="vectors">
                The vectors composing the shape to which
                the algorithm is applied.
            </param>
            <returns>The transformed vectors after the iteration-step.</returns>
        </member>
        <member name="M:Algorithms.Other.KochSnowflake.Rotate(System.Numerics.Vector2,System.Single)">
            <summary>
                Standard rotation of a 2D vector with a rotation matrix
                (see https://en.wikipedia.org/wiki/Rotation_matrix ).
            </summary>
            <param name="vector">The vector to be rotated.</param>
            <param name="angleInDegrees">The angle by which to rotate the vector.</param>
            <returns>The rotated vector.</returns>
        </member>
        <member name="M:Algorithms.Other.KochSnowflake.GetBitmap(System.Collections.Generic.List{System.Numerics.Vector2},System.Int32,System.Int32)">
            <summary>
                Utility-method to render the Koch snowflake to a bitmap.
            </summary>
            <param name="vectors">The vectors defining the edges to be rendered.</param>
            <param name="bitmapWidth">The width of the rendered bitmap.</param>
            <param name="bitmapHeight">The height of the rendered bitmap.</param>
            <returns>The bitmap of the rendered edges.</returns>
        </member>
        <member name="T:Algorithms.Other.Luhn">
            <summary>
                Luhn algorithm is a simple
                checksum formula used to validate
                a variety of identification numbers,
                such as credit card numbers.
                More information on the link:
                https://en.wikipedia.org/wiki/Luhn_algorithm.
            </summary>
        </member>
        <member name="M:Algorithms.Other.Luhn.Validate(System.String)">
            <summary>
                Checking the validity of a sequence of numbers.
            </summary>
            <param name="number">The number that will be checked for validity.</param>
            <returns>
                True: Number is valid.
                False: Number isn`t valid.
            </returns>
        </member>
        <member name="M:Algorithms.Other.Luhn.GetLostNum(System.String)">
            <summary>
                This algorithm only finds one number.
                In place of the unknown digit, put "x".
            </summary>
            <param name="number">The number in which to find the missing digit.</param>
            <returns>Missing digit.</returns>
        </member>
        <member name="M:Algorithms.Other.Luhn.GetSum(System.String)">
            <summary>
                Computes the sum found by the algorithm.
            </summary>
            <param name="number">The number for which the sum will be found.</param>
            <returns>Sum.</returns>
        </member>
        <member name="T:Algorithms.Other.Mandelbrot">
            <summary>
                The Mandelbrot set is the set of complex numbers "c" for which the series
                "z_(n+1) = z_n * z_n + c" does not diverge, i.e. remains bounded. Thus, a
                complex number "c" is a member of the Mandelbrot set if, when starting with
                "z_0 = 0" and applying the iteration repeatedly, the absolute value of
                "z_n" remains bounded for all "n > 0". Complex numbers can be written as
                "a + b*i": "a" is the real component, usually drawn on the x-axis, and "b*i"
                is the imaginary component, usually drawn on the y-axis. Most visualizations
                of the Mandelbrot set use a color-coding to indicate after how many steps in
                the series the numbers outside the set cross the divergence threshold.
                Images of the Mandelbrot set exhibit an elaborate and infinitely
                complicated boundary that reveals progressively ever-finer recursive detail
                at increasing magnifications, making the boundary of the Mandelbrot set a
                fractal curve.
                (description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set)
                (see also https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set).
            </summary>
        </member>
        <member name="M:Algorithms.Other.Mandelbrot.GetBitmap(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
                Method to generate the bitmap of the Mandelbrot set. Two types of coordinates
                are used: bitmap-coordinates that refer to the pixels and figure-coordinates
                that refer to the complex numbers inside and outside the Mandelbrot set. The
                figure-coordinates in the arguments of this method determine which section
                of the Mandelbrot set is viewed. The main area of the Mandelbrot set is
                roughly between "-1.5 &lt; x &lt; 0.5" and "-1 &lt; y &lt; 1" in the figure-coordinates.
                To save the bitmap the command 'GetBitmap().Save("Mandelbrot.png")' can be used.
            </summary>
            <param name="bitmapWidth">The width of the rendered bitmap.</param>
            <param name="bitmapHeight">The height of the rendered bitmap.</param>
            <param name="figureCenterX">The x-coordinate of the center of the figure.</param>
            <param name="figureCenterY">The y-coordinate of the center of the figure.</param>
            <param name="figureWidth">The width of the figure.</param>
            <param name="maxStep">Maximum number of steps to check for divergent behavior.</param>
            <param name="useDistanceColorCoding">Render in color or black and white.</param>
            <returns>The bitmap of the rendered Mandelbrot set.</returns>
        </member>
        <member name="M:Algorithms.Other.Mandelbrot.BlackAndWhiteColorMap(System.Double)">
            <summary>
                Black and white color-coding that ignores the relative distance. The Mandelbrot
                set is black, everything else is white.
            </summary>
            <param name="distance">Distance until divergence threshold.</param>
            <returns>The color corresponding to the distance.</returns>
        </member>
        <member name="M:Algorithms.Other.Mandelbrot.ColorCodedColorMap(System.Double)">
            <summary>
                Color-coding taking the relative distance into account. The Mandelbrot set
                is black.
            </summary>
            <param name="distance">Distance until divergence threshold.</param>
            <returns>The color corresponding to the distance.</returns>
        </member>
        <member name="M:Algorithms.Other.Mandelbrot.GetDistance(System.Double,System.Double,System.Int32)">
            <summary>
                Return the relative distance (ratio of steps taken to maxStep) after which the complex number
                constituted by this x-y-pair diverges. Members of the Mandelbrot set do not
                diverge so their distance is 1.
            </summary>
            <param name="figureX">The x-coordinate within the figure.</param>
            <param name="figureY">The y-coordinate within the figure.</param>
            <param name="maxStep">Maximum number of steps to check for divergent behavior.</param>
            <returns>The relative distance as the ratio of steps taken to maxStep.</returns>
        </member>
        <member name="T:Algorithms.Other.ParetoOptimization">
            <summary>
            Almost all real complex decision-making task is described by more than one criterion.
            Therefore, the methods of multicriteria optimization are important. For a wide range
            of tasks multicriteria optimization, described by some axioms of "reasonable"
            behavior in the process of choosing from a set of possible solutions X, each set of
            selected solutions Sel X should be contained in a set optimal for Pareto.
            </summary>
        </member>
        <member name="M:Algorithms.Other.ParetoOptimization.Optimize(System.Collections.Generic.List{System.Collections.Generic.List{System.Decimal}})">
            <summary>
            Performs decision optimizations by using Paretor's optimization algorithm.
            </summary>
            <param name="matrix">Contains a collection of the criterias sets.</param>
            <returns>An optimized collection of the criterias sets.</returns>
        </member>
        <member name="M:Algorithms.Other.ParetoOptimization.GetMinimalPairwiseDifference(System.Collections.Generic.List{System.Decimal},System.Collections.Generic.List{System.Decimal})">
            <summary>
            Calculates the smallest difference between criteria of input decisions.
            </summary>
            <param name="arr1">Criterias of the first decision.</param>
            <param name="arr2">Criterias of the second decision.</param>
            <returns>Values that represent the smallest difference between criteria of input decisions.</returns>
        </member>
        <member name="T:Algorithms.Other.PollardsRhoFactorizing">
            <summary>Implementation of the Pollard's rho algorithm.
            Algorithm for integer factorization.
            Wiki: https://en.wikipedia.org/wiki/Pollard's_rho_algorithm.
            </summary>
        </member>
        <member name="T:Algorithms.Other.RgbHsvConversion">
            <summary>
                The RGB color model is an additive color model in which red, green, and
                blue light are added together in various ways to reproduce a broad array of
                colors. The name of the model comes from the initials of the three additive
                primary colors, red, green, and blue. Meanwhile, the HSV representation
                models how colors appear under light. In it, colors are represented using
                three components: hue, saturation and (brightness-)value. This class
                provides methods for converting colors from one representation to the other.
                (description adapted from https://en.wikipedia.org/wiki/RGB_color_model and
                https://en.wikipedia.org/wiki/HSL_and_HSV).
            </summary>
        </member>
        <member name="M:Algorithms.Other.RgbHsvConversion.HsvToRgb(System.Double,System.Double,System.Double)">
            <summary>
                Conversion from the HSV-representation to the RGB-representation.
            </summary>
            <param name="hue">Hue of the color.</param>
            <param name="saturation">Saturation of the color.</param>
            <param name="value">Brightness-value of the color.</param>
            <returns>The tuple of RGB-components.</returns>
        </member>
        <member name="M:Algorithms.Other.RgbHsvConversion.RgbToHsv(System.Byte,System.Byte,System.Byte)">
            <summary>
                Conversion from the RGB-representation to the HSV-representation.
            </summary>
            <param name="red">Red-component of the color.</param>
            <param name="green">Green-component of the color.</param>
            <param name="blue">Blue-component of the color.</param>
            <returns>The tuple of HSV-components.</returns>
        </member>
        <member name="T:Algorithms.Other.SieveOfEratosthenes">
            <summary>
                Implements the Sieve of Eratosthenes.
            </summary>
        </member>
        <member name="M:Algorithms.Other.SieveOfEratosthenes.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Algorithms.Other.SieveOfEratosthenes"/> class.
            Uses the Sieve of Eratosthenes to precalculate the primes from 0 up to maximumNumberToCheck.
            Requires enough memory to allocate maximumNumberToCheck bytes.
            https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes .
            </summary>
            <param name="maximumNumberToCheck">long which specifies the largest number you wish to know if it is prime.</param>
        </member>
        <member name="P:Algorithms.Other.SieveOfEratosthenes.MaximumNumber">
            <summary>
            Gets the maximumNumberToCheck the class was instantiated with.
            </summary>
        </member>
        <member name="M:Algorithms.Other.SieveOfEratosthenes.IsPrime(System.Int64)">
            <summary>
            Returns a boolean indicating whether the number is prime.
            </summary>
            <param name="numberToCheck">The number you desire to know if it is prime or not.</param>
            <returns>A boolean indicating whether the number is prime or not.</returns>
        </member>
        <member name="M:Algorithms.Other.SieveOfEratosthenes.GetPrimes">
            <summary>
            Returns an IEnumerable of long primes in asending order.
            </summary>
            <returns>Primes in ascending order.</returns>
        </member>
        <member name="T:Algorithms.Other.WelfordsVariance">
            <summary>Implementation of Welford's variance algorithm.
            </summary>
        </member>
        <member name="F:Algorithms.Other.WelfordsVariance.count">
            <summary>
                Mean accumulates the mean of the entire dataset,
                m2 aggregates the squared distance from the mean,
                count aggregates the number of samples seen so far.
            </summary>
        </member>
        <member name="M:Algorithms.Problems.DynamicProgramming.CoinChange.DynamicCoinChangeSolver.GenerateSingleCoinChanges(System.Int32,System.Int32[])">
            <summary>
            Generates an array of changes for current coin.
            For instance, having coin C = 6 and array A = [1,3,4] it returns an array R = [2,3,5].
            Because, 6 - 4 = 2, 6 - 3 = 3, 6 - 1 = 5.
            </summary>
            <param name="coin">The value of the coin to be exchanged.</param>
            <param name="coins">An array of available coins.</param>
            <returns>Array of changes of current coins by available coins.</returns>
        </member>
        <member name="M:Algorithms.Problems.DynamicProgramming.CoinChange.DynamicCoinChangeSolver.GenerateChangesDictionary(System.Int32,System.Int32[])">
            <summary>
            Given a positive integer N, such as coin.
            Generates a change dictionary for all values [1,N].
            Used in so-called backward induction in search of the minimum exchange.
            </summary>
            <param name="coin">The value of coin.</param>
            <param name="coins">Array of available coins.</param>
            <returns>Change dictionary for all values [1,N], where N is the coin.</returns>
        </member>
        <member name="M:Algorithms.Problems.DynamicProgramming.CoinChange.DynamicCoinChangeSolver.GetMinimalNextCoin(System.Int32,System.Collections.Generic.Dictionary{System.Int32,System.Int32[]})">
            <summary>
            Gets a next coin value, such that changes array contains the minimal change overall possible changes.
            For example, having coin N = 6 and A = [1,3,4] coins array.
            The minimum next coin for 6 will be 3, because changes of 3 by A = [1,3,4] contains 0, the minimal change.
            </summary>
            <param name="coin">Coin to be exchanged.</param>
            <param name="exchanges">Dictionary of exchanges for [1, coin].</param>
            <returns>Index of the next coin with minimal exchange.</returns>
        </member>
        <member name="M:Algorithms.Problems.DynamicProgramming.CoinChange.DynamicCoinChangeSolver.MakeCoinChangeDynamic(System.Int32,System.Int32[])">
            <summary>
            Performs a coin change such that an amount of coins is minimal.
            </summary>
            <param name="coin">The value of coin to be exchanged.</param>
            <param name="coins">An array of available coins.</param>
            <returns>Array of exchanges.</returns>
        </member>
        <member name="T:Algorithms.Problems.DynamicProgramming.LevenshteinDistance">
            <summary>
                <para>
                    Levenshtein distance between two words is the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into the other.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Levenshtein_distance.
                </para>
            </summary>
        </member>
        <member name="M:Algorithms.Problems.DynamicProgramming.LevenshteinDistance.Calculate(System.String,System.String)">
            <summary>
                Calculates Levenshtein distance.
                Time and space complexity is O(ab) where a and b are the lengths of the source and target strings.
            </summary>
            <param name="source">Source string.</param>
            <param name="target">Target string.</param>
            <returns>Levenshtein distance between source and target strings.</returns>
        </member>
        <member name="M:Algorithms.Problems.NQueens.BacktrackingNQueensSolver.BacktrackSolve(System.Int32)">
            <summary>
                Solves N-Queen Problem given a n dimension chessboard and using backtracking with recursion algorithm.
                If we find a dead-end within or current solution we go back and try another position for queen.
            </summary>
            <param name="n">Number of rows.</param>
            <returns>All solutions.</returns>
        </member>
        <member name="M:Algorithms.Problems.NQueens.BacktrackingNQueensSolver.CanPlace(System.Boolean[0:,0:],System.Int32,System.Int32)">
            <summary>
                Checks whether current queen can be placed in current position,
                outside attacking range of another queen.
            </summary>
            <param name="board">Source board.</param>
            <param name="row">Row coordinate.</param>
            <param name="col">Col coordinate.</param>
            <returns>true if queen can be placed in given chessboard coordinates; false otherwise.</returns>
        </member>
        <member name="M:Algorithms.Problems.StableMarriage.GaleShapley.Match(Algorithms.Problems.StableMarriage.Proposer[],Algorithms.Problems.StableMarriage.Accepter[])">
            <summary>
                Finds a stable matching between two equal sets of elements (fills EngagedTo properties).
                time complexity: O(n^2), where n - array size.
                Guarantees:
                - Everyone is matched
                - Matches are stable (there is no better accepter, for any given proposer, which would accept a new match).
                Presented and proven by David Gale and Lloyd Shapley in 1962.
            </summary>
        </member>
        <member name="T:Algorithms.Search.AStar.AStar">
            <summary>
                Contains the code for A* Pathfinding.
            </summary>
        </member>
        <member name="M:Algorithms.Search.AStar.AStar.ResetNodes(System.Collections.Generic.List{Algorithms.Search.AStar.Node})">
            <summary>
                Resets the Nodes in the list.
            </summary>
            <param name="nodes">Resets the nodes to be used again.</param>
        </member>
        <member name="M:Algorithms.Search.AStar.AStar.GeneratePath(Algorithms.Search.AStar.Node)">
            <summary>
                Generates the Path from an (solved) node graph, before it gets reset.
            </summary>
            <param name="target">The node where we want to go.</param>
            <returns>The Path to the target node.</returns>
        </member>
        <member name="M:Algorithms.Search.AStar.AStar.Compute(Algorithms.Search.AStar.Node,Algorithms.Search.AStar.Node)">
            <summary>
                Computes the path from => to.
            </summary>
            <param name="from">Start node.</param>
            <param name="to">end node.</param>
            <returns>Path from start to end.</returns>
        </member>
        <member name="T:Algorithms.Search.AStar.Node">
            <summary>
                Contains Positional and other information about a single node.
            </summary>
        </member>
        <member name="P:Algorithms.Search.AStar.Node.TotalCost">
            <summary>
                Gets the Total cost of the Node.
                The Current Costs + the estimated costs.
            </summary>
        </member>
        <member name="P:Algorithms.Search.AStar.Node.EstimatedCost">
            <summary>
                Gets or sets the Distance between this node and the target node.
            </summary>
        </member>
        <member name="P:Algorithms.Search.AStar.Node.TraversalCostMultiplier">
            <summary>
                Gets a value indicating whether how costly it is to traverse over this node.
            </summary>
        </member>
        <member name="P:Algorithms.Search.AStar.Node.CurrentCost">
            <summary>
                Gets or sets a value indicating whether to go from the start node to this node.
            </summary>
        </member>
        <member name="P:Algorithms.Search.AStar.Node.State">
            <summary>
                Gets or sets the state of the Node
                Can be Unconsidered(Default), Open and Closed.
            </summary>
        </member>
        <member name="P:Algorithms.Search.AStar.Node.Traversable">
            <summary>
                Gets a value indicating whether the node is traversable.
            </summary>
        </member>
        <member name="P:Algorithms.Search.AStar.Node.ConnectedNodes">
            <summary>
                Gets or sets a list of all connected nodes.
            </summary>
        </member>
        <member name="P:Algorithms.Search.AStar.Node.Parent">
            <summary>
                Gets or sets he "previous" node that was processed before this node.
            </summary>
        </member>
        <member name="P:Algorithms.Search.AStar.Node.Position">
            <summary>
                Gets the positional information of the node.
            </summary>
        </member>
        <member name="M:Algorithms.Search.AStar.Node.CompareTo(Algorithms.Search.AStar.Node)">
            <summary>
                Compares the Nodes based on their total costs.
                Total Costs: A* Pathfinding.
                Current: Djikstra Pathfinding.
                Estimated: Greedy Pathfinding.
            </summary>
            <param name="other">The other node.</param>
            <returns>A comparison between the costs.</returns>
        </member>
        <member name="M:Algorithms.Search.AStar.Node.DistanceTo(Algorithms.Search.AStar.Node)">
            <summary>
                Returns the distance to the other node.
            </summary>
            <param name="other">The other node.</param>
            <returns>Distance between this and other.</returns>
        </member>
        <member name="T:Algorithms.Search.AStar.NodeState">
            <summary>
                The states the nodes can have.
            </summary>
        </member>
        <member name="F:Algorithms.Search.AStar.NodeState.Unconsidered">
            <summary>
                TODO.
            </summary>
        </member>
        <member name="F:Algorithms.Search.AStar.NodeState.Open">
            <summary>
                TODO.
            </summary>
        </member>
        <member name="F:Algorithms.Search.AStar.NodeState.Closed">
            <summary>
                TODO.
            </summary>
        </member>
        <member name="T:Algorithms.Search.AStar.PathfindingException">
            <summary>
                A pathfinding exception is thrown when the Pathfinder encounters a critical error and can not continue.
            </summary>
        </member>
        <member name="T:Algorithms.Search.AStar.PriorityQueue`1">
            <summary>
                Generic Priority Queue.
                List based.
            </summary>
            <typeparam name="T">
                The type that will be stored.
                Has to be IComparable of T.
            </typeparam>
        </member>
        <member name="M:Algorithms.Search.AStar.PriorityQueue`1.#ctor(System.Int32,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Algorithms.Search.AStar.PriorityQueue`1" /> class.
            </summary>
            <param name="capacity">Initial capacity.</param>
            <param name="isDescending">Should Reverse Sort order? Default: false.</param>
        </member>
        <member name="M:Algorithms.Search.AStar.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Algorithms.Search.AStar.PriorityQueue`1" /> class.
            </summary>
            <param name="collection">Internal data.</param>
            <param name="isDescending">Should Reverse Sort order? Default: false.</param>
        </member>
        <member name="P:Algorithms.Search.AStar.PriorityQueue`1.Count">
            <summary>
                Gets Number of enqueued items.
            </summary>
        </member>
        <member name="M:Algorithms.Search.AStar.PriorityQueue`1.Enqueue(`0)">
            <summary>
                Enqueues an item into the Queue.
            </summary>
            <param name="x">The item to Enqueue.</param>
        </member>
        <member name="M:Algorithms.Search.AStar.PriorityQueue`1.Dequeue">
            <summary>
                Dequeues the item at the end of the queue.
            </summary>
            <returns>The dequeued item.</returns>
        </member>
        <member name="M:Algorithms.Search.AStar.PriorityQueue`1.Peek">
            <summary>
                Returns the next element in the queue without dequeuing.
            </summary>
            <returns>The next element of the queue.</returns>
        </member>
        <member name="M:Algorithms.Search.AStar.PriorityQueue`1.Clear">
            <summary>
                Clears the Queue.
            </summary>
        </member>
        <member name="M:Algorithms.Search.AStar.PriorityQueue`1.GetData">
            <summary>
                Returns the Internal Data.
            </summary>
            <returns>The internal data structure.</returns>
        </member>
        <member name="T:Algorithms.Search.AStar.VecN">
            <summary>
                Vector Struct with N Dimensions.
            </summary>
        </member>
        <member name="M:Algorithms.Search.AStar.VecN.#ctor(System.Double[])">
            <summary>
                Initializes a new instance of the <see cref="T:Algorithms.Search.AStar.VecN" /> struct.
            </summary>
            <param name="vals">Vector components as array.</param>
        </member>
        <member name="P:Algorithms.Search.AStar.VecN.N">
            <summary>
                Gets the dimension count of this vector.
            </summary>
        </member>
        <member name="M:Algorithms.Search.AStar.VecN.SqrLength">
            <summary>
                Returns the Length squared.
            </summary>
            <returns>The squared length of the vector.</returns>
        </member>
        <member name="M:Algorithms.Search.AStar.VecN.Length">
            <summary>
                Returns the Length of the vector.
            </summary>
            <returns>Length of the Vector.</returns>
        </member>
        <member name="M:Algorithms.Search.AStar.VecN.Distance(Algorithms.Search.AStar.VecN)">
            <summary>
                Returns the Distance between this and other.
            </summary>
            <param name="other">Other vector.</param>
            <returns>The distance between this and other.</returns>
        </member>
        <member name="M:Algorithms.Search.AStar.VecN.SqrDistance(Algorithms.Search.AStar.VecN)">
            <summary>
                Returns the squared Distance between this and other.
            </summary>
            <param name="other">Other vector.</param>
            <returns>The squared distance between this and other.</returns>
        </member>
        <member name="M:Algorithms.Search.AStar.VecN.Subtract(Algorithms.Search.AStar.VecN)">
            <summary>
                Substracts other from this vector.
            </summary>
            <param name="other">Other vector.</param>
            <returns>The new vector.</returns>
        </member>
        <member name="M:Algorithms.Search.AStar.VecN.Equals(Algorithms.Search.AStar.VecN)">
            <summary>
                Is used to compare Vectors with each other.
            </summary>
            <param name="other">The vector to be compared.</param>
            <returns>A value indicating if other has the same values as this.</returns>
        </member>
        <member name="T:Algorithms.Search.BinarySearcher`1">
            <summary>
                Binary Searcher checks an array for element specified by checking
                if element is greater or less than the half being checked.
                time complexity: O(log(n)),
                space complexity: O(1).
                Note: Array must be sorted beforehand.
            </summary>
            <typeparam name="T">Type of element stored inside array. 2.</typeparam>
        </member>
        <member name="M:Algorithms.Search.BinarySearcher`1.FindIndex(`0[],`0)">
            <summary>
                Finds index of an array by using binary search.
            </summary>
            <param name="sortedData">Sorted array to search in.</param>
            <param name="item">Item to search for.</param>
            <returns>Index of item that equals to item searched for or -1 if none found.</returns>
        </member>
        <member name="T:Algorithms.Search.BoyerMoore`1">
            <summary>
                A Boyer-Moore majority finder algorithm implementation.
            </summary>
            <typeparam name="T">Type of element stored inside array.</typeparam>
        </member>
        <member name="T:Algorithms.Search.FastSearcher">
            <summary>
                The idea: you could combine the advantages from both binary-search and interpolation search algorithm.
                Time complexity:
                worst case: Item couldn't be found: O(log n),
                average case: O(log log n),
                best case: O(1).
                Note: This algorithm is recursive and the array has to be sorted beforehand.
            </summary>
        </member>
        <member name="M:Algorithms.Search.FastSearcher.FindIndex(System.Span{System.Int32},System.Int32)">
            <summary>
                Finds index of first item in array that satisfies specified term
                throws ItemNotFoundException if the item couldn't be found.
            </summary>
            <param name="array">Span of sorted numbers which will be used to find the item.</param>
            <param name="item">Term to check against.</param>
            <returns>Index of first item that satisfies term.</returns>
            <exception cref="T:Utilities.Exceptions.ItemNotFoundException"> Gets thrown when the given item couldn't be found in the array.</exception>
        </member>
        <member name="T:Algorithms.Search.FibonacciSearcher`1">
            <summary>
                Class that implements Fibonacci search algorithm.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Search.FibonacciSearcher`1.FindIndex(`0[],`0)">
            <summary>
                Finds the index of the item searched for in the array.
                Time complexity:
                worst-case: O(log n),
                average-case: O(log n),
                best-case: O(1).
            </summary>
            <param name="array">Sorted array to be searched in. Cannot be null.</param>
            <param name="item">Item to be searched for. Cannot be null.</param>
            <returns>If an item is found, return index. If the array is empty or an item is not found, return -1.</returns>
            <exception cref="T:System.ArgumentNullException">Gets thrown when the given array or item is null.</exception>
        </member>
        <member name="T:Algorithms.Search.InterpolationSearch">
            <summary>
                Class that implements interpolation search algorithm.
            </summary>
        </member>
        <member name="M:Algorithms.Search.InterpolationSearch.FindIndex(System.Int32[],System.Int32)">
            <summary>
                Finds the index of the item searched for in the array.
                Algorithm performance:
                worst-case: O(n),
                average-case: O(log(log(n))),
                best-case: O(1).
            </summary>
            <param name="sortedArray">Array with sorted elements to be searched in. Cannot be null.</param>
            <param name="val">Value to be searched for. Cannot be null.</param>
            <returns>If an item is found, return index, else return -1.</returns>
        </member>
        <member name="T:Algorithms.Search.JumpSearcher`1">
            <summary>
                Jump Search checks fewer elements by jumping ahead by fixed steps.
                The optimal steps to jump is √n, where n refers to the number of elements in the array.
                Time Complexity: O(√n)
                Note: The array has to be sorted beforehand.
            </summary>
            <typeparam name="T">Type of the array element.</typeparam>
        </member>
        <member name="M:Algorithms.Search.JumpSearcher`1.FindIndex(`0[],`0)">
            <summary>
                Find the index of the item searched for in the array.
            </summary>
            <param name="sortedArray">Sorted array to be search in. Cannot be null.</param>
            <param name="searchItem">Item to be search for. Cannot be null.</param>
            <returns>If item is found, return index. If array is empty or item not found, return -1.</returns>
        </member>
        <member name="T:Algorithms.Search.LinearSearcher`1">
            <summary>
                Class that implements linear search algorithm.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Search.LinearSearcher`1.Find(`0[],System.Func{`0,System.Boolean})">
            <summary>
                Finds first item in array that satisfies specified term
                Time complexity: O(n)
                Space complexity: O(1).
            </summary>
            <param name="data">Array to search in.</param>
            <param name="term">Term to check against.</param>
            <returns>First item that satisfies term.</returns>
        </member>
        <member name="M:Algorithms.Search.LinearSearcher`1.FindIndex(`0[],System.Func{`0,System.Boolean})">
            <summary>
                Finds index of first item in array that satisfies specified term
                Time complexity: O(n)
                Space complexity: O(1).
            </summary>
            <param name="data">Array to search in.</param>
            <param name="term">Term to check against.</param>
            <returns>Index of first item that satisfies term or -1 if none found.</returns>
        </member>
        <member name="T:Algorithms.Search.RecursiveBinarySearcher`1">
            <summary>
                RecursiveBinarySearcher.
            </summary>
            <typeparam name="T">Type of searcher target.</typeparam>
        </member>
        <member name="M:Algorithms.Search.RecursiveBinarySearcher`1.FindIndex(System.Collections.Generic.IList{`0},`0)">
            <summary>
                Finds index of item in collection that equals to item searched for,
                time complexity: O(log(n)),
                space complexity: O(1),
                where n - collection size.
            </summary>
            <param name="collection">Sorted collection to search in.</param>
            <param name="item">Item to search for.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if input collection is null.</exception>
            <returns>Index of item that equals to item searched for or -1 if none found.</returns>
        </member>
        <member name="M:Algorithms.Search.RecursiveBinarySearcher`1.FindIndex(System.Collections.Generic.IList{`0},`0,System.Int32,System.Int32)">
            <summary>
                Finds index of item in array that equals to item searched for,
                time complexity: O(log(n)),
                space complexity: O(1),
                where n - array size.
            </summary>
            <param name="collection">Sorted array to search in.</param>
            <param name="item">Item to search for.</param>
            <param name="leftIndex">Minimum search range.</param>
            <param name="rightIndex">Maximum search range.</param>
            <returns>Index of item that equals to item searched for or -1 if none found.</returns>
        </member>
        <member name="T:Algorithms.Sequences.AllOnesSequence">
            <summary>
                <para>
                    The all ones sequence.
                </para>
                <para>
                    OEIS: https://oeis.org/A000012.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.AllOnesSequence.Sequence">
            <summary>
                Gets all ones sequence.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.AllThreesSequence">
            <summary>
                <para>
                    The all threes sequence.
                </para>
                <para>
                    OEIS: https://oeis.org/A010701.
                </para>
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.AllTwosSequence">
            <summary>
                <para>
                    The all twos sequence.
                </para>
                <para>
                    OEIS: https://oeis.org/A007395.
                </para>
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.BinaryPrimeConstantSequence">
            <summary>
                <para>
                    Sequence of binary prime constant
                    (Characteristic function of primes: 1 if n is prime, else 0).
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Prime_constant.
                </para>
                <para>
                    OEIS: https://oeis.org/A010051.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.BinaryPrimeConstantSequence.Sequence">
            <summary>
            Gets sequence of binary prime constant.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.BinomialSequence">
            <summary>
                <para>
                    Sequence of binomial coefficients.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient.
                </para>
                <para>
                    OEIS: http://oeis.org/A007318.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.BinomialSequence.Sequence">
            <summary>
                Gets sequence of binomial coefficients.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.CakeNumbersSequence">
            <summary>
                <para>
                    Cake numbers: maximal number of pieces resulting from n planar cuts through a cube
                    (or cake): C(n+1,3) + n + 1.
                </para>
                <para>
                    OEIS: https://oeis.org/A000125.
                </para>
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.CatalanSequence">
            <summary>
                <para>
                    Catalan numbers: C[n+1] = (2*(2*n+1)*C[n])/(n+2).
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Catalan_number.
                </para>
                <para>
                    OEIS:http://oeis.org/A000108.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.CatalanSequence.Sequence">
            <summary>
                Gets sequence of Catalan numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.CentralPolygonalNumbersSequence">
            <summary>
                <para>
                    Central polygonal numbers (the Lazy Caterer's sequence): n(n+1)/2 + 1; or, maximal number of pieces
                    formed when slicing a pancake with n cuts.
                </para>
                <para>
                    OEIS: https://oeis.org/A000124.
                </para>
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.CubesSequence">
            <summary>
                <para>
                    Sequence of cube numbers.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Cube_(algebra).
                </para>
                <para>
                    OEIS: https://oeis.org/A000578.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.CubesSequence.Sequence">
            <summary>
            Gets sequence of cube numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.DivisorsCountSequence">
            <summary>
                <para>
                    Sequence of the number of divisors of n, starting with 1.
                </para>
                <para>
                    OEIS: https://oeis.org/A000005.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.DivisorsCountSequence.Sequence">
            <summary>
                Gets sequence of number of divisors for n, starting at 1.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.EuclidNumbersSequence">
            <summary>
                <para>
                    Sequence of Euclid numbers: 1 + product of the first n primes.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Euclid_number.
                </para>
                <para>
                    OEIS: https://oeis.org/A006862.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.EuclidNumbersSequence.Sequence">
            <summary>
            Gets sequence of Euclid numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.EulerTotientSequence">
            <summary>
                <para>
                    Sequence of Euler totient function phi(n).
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Euler%27s_totient_function.
                </para>
                <para>
                    OEIS: https://oeis.org/A000010.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.EulerTotientSequence.Sequence">
            <summary>
                <para>
                    Gets sequence of Euler totient function phi(n).
                </para>
                <para>
                    'n' is copied from value of the loop of i that's being enumerated over.
                    1) Initialize result as n
                    2) Consider every number 'factor' (where 'factor' is a prime divisor of n).
                       If factor divides n, then do following
                       a) Subtract all multiples of factor from 1 to n [all multiples of factor
                          will have gcd more than 1 (at least factor) with n]
                       b) Update n by repeatedly dividing it by factor.
                    3) If the reduced n is more than 1, then remove all multiples
                       of n from result.
                </para>
                <para>
                    Base code was from https://www.geeksforgeeks.org/eulers-totient-function/.
                 </para>
                <para>
                    Implementation avoiding floating point operations was used for base
                    and replacement of loop going from 1 to sqrt(n) was replaced with
                    List of prime factors.
                </para>
            </summary>
        </member>
        <member name="M:Algorithms.Sequences.EulerTotientSequence.PrimeFactors(System.Numerics.BigInteger)">
            <summary>
                <para>
                    Uses the prime sequence to find all prime factors of the
                    number we're looking at.
                </para>
                <para>
                    The prime sequence is examined until its value squared is
                    less than or equal to target, and checked to make sure it
                    evenly divides the target.  If it evenly divides, it's added
                    to the result which is returned as a List.
                </para>
            </summary>
            <param name="target">Number that is being factored.</param>
            <returns>List of prime factors of target.</returns>
        </member>
        <member name="T:Algorithms.Sequences.FactorialSequence">
            <summary>
                <para>
                    Sequence of factorial numbers.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Factorial.
                </para>
                <para>
                    OEIS: https://oeis.org/A000142.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.FactorialSequence.Sequence">
            <summary>
                Gets sequence of factorial numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.FermatNumbersSequence">
            <summary>
                <para>
                    Sequence of Fermat numbers: a(n) = 2^(2^n) + 1.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Fermat_number.
                </para>
                <para>
                    OEIS: https://oeis.org/A000215.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.FermatNumbersSequence.Sequence">
            <summary>
            Gets sequence of Fermat numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.FermatPrimesSequence">
            <summary>
                <para>
                    Sequence of Fermat primes: primes of the form 2^(2^k) + 1, for some k >= 0.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Fermat_number.
                </para>
                <para>
                    OEIS: https://oeis.org/A019434.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.FermatPrimesSequence.Sequence">
            <summary>
            Gets sequence of Fermat primes.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.FibonacciSequence">
            <summary>
                <para>
                    Fibonacci sequence.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Fibonacci_number.
                </para>
                <para>
                    OEIS: https://oeis.org/A000045.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.FibonacciSequence.Sequence">
            <summary>
                Gets Fibonacci sequence.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.GolombsSequence">
            <summary>
                <para>
                    Golomb's sequence. a(n) is the number of times n occurs in the sequence, starting with a(1) = 1.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Golomb_sequence.
                </para>
                <para>
                    OEIS: https://oeis.org/A001462.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.GolombsSequence.Sequence">
            <summary>
                Gets Golomb's sequence.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.ISequence">
            <summary>
                Common interface for all integer sequences.
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.ISequence.Sequence">
            <summary>
                Gets sequence as enumerable.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.KolakoskiSequence">
            <summary>
                <para>
                    Kolakoski sequence; n-th element is the length of the n-th run in the sequence itself.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Kolakoski_sequence.
                </para>
                <para>
                    OEIS: https://oeis.org/A000002.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.KolakoskiSequence.Sequence">
            <summary>
            Gets Kolakoski sequence.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.KolakoskiSequence2">
            <summary>
                <para>
                    Kolakoski sequence; n-th element is the length of the n-th run in the sequence itself.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Kolakoski_sequence.
                </para>
                <para>
                    OEIS: https://oeis.org/A000002.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.KolakoskiSequence2.Sequence">
            <summary>
            Gets Kolakoski sequence.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.KummerNumbersSequence">
            <summary>
                <para>
                    Sequence of Kummer numbers (also called Euclid numbers of the second kind):
                    -1 + product of first n consecutive primes.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Euclid_number.
                </para>
                <para>
                    OEIS: https://oeis.org/A057588.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.KummerNumbersSequence.Sequence">
            <summary>
            Gets sequence of Kummer numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.LucasNumbersBeginningAt2Sequence">
            <summary>
                <para>
                    Sequence of Lucas number values.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Lucas_number.
                </para>
                <para>
                    OEIS: http://oeis.org/A000032.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.LucasNumbersBeginningAt2Sequence.Sequence">
             <summary>
                 <para>
                     Gets Lucas number sequence.
                 </para>
                 <para>
                     Lucas numbers follow the same type of operation that the Fibonacci (A000045)
                     sequence performs with starting values of 2, 1 versus 0,1.  As Fibonacci does,
                     the ratio between two consecutive Lucas numbers converges to phi.
                 </para>
                 <para>
                     This implementation is similar to A000204, but starts with the index of 0, thus having the
                     initial values being (2,1) instead of starting at index 1 with initial values of (1,3).
                 </para>
                 <para>
                     A simple relationship to Fibonacci can be shown with L(n) = F(n-1) + F(n+1), n>= 1.
            
                     n |  L(n) | F(n-1) | F(n+1)
                     --|-------|--------+--------+
                     0 |   2   |        |        |
                     1 |   1   |      0 |      1 |
                     2 |   3   |      1 |      2 |
                     3 |   4   |      1 |      3 |
                     4 |   7   |      2 |      5 |
                     5 |  11   |      3 |      8 |
                     --|-------|--------+--------+.
                 </para>
             </summary>
        </member>
        <member name="T:Algorithms.Sequences.MakeChangeSequence">
            <summary>
                <para>
                    Number of ways of making change for n cents using coins of 1, 2, 5, 10 cents.
                </para>
                <para>
                    OEIS: https://oeis.org/A000008.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.MakeChangeSequence.Sequence">
            <summary>
                <para>
                    Gets sequence of number of ways of making change for n cents
                    using coins of 1, 2, 5, 10 cents.
                </para>
                <para>
                    Uses formula from OEIS page by Michael Somos
                    along with first 17 values to prevent index issues.
                </para>
                <para>
                    Formula:
                    a(n) = a(n-2) +a(n-5) - a(n-7) + a(n-10) - a(n-12) - a(n-15) + a(n-17) + 1.
                </para>
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.MatchstickTriangleSequence">
            <summary>
                <para>
                    Sequence of number of triangles in triangular matchstick arrangement of side n for n>=0.
                </para>
                <para>
                    M. E. Larsen, The eternal triangle – a history of a counting problem, College Math. J., 20 (1989), 370-392.
                    https://web.math.ku.dk/~mel/mel.pdf.
                </para>
                <para>
                    OEIS: http://oeis.org/A002717.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.MatchstickTriangleSequence.Sequence">
             <summary>
                 <para>
                     Gets number of triangles contained in an triangular arrangement of matchsticks of side length n.
                 </para>
                 <para>
                     This also counts the subset of smaller triangles contained within the arrangement.
                 </para>
                 <para>
                     Based on the PDF referenced above, the sequence is derived from step 8, using the resulting equation
                     of f(n) = (n(n+2)(2n+1) -(delta)(n)) / 8.  Using BigInteger values, we can effectively remove
                     (delta)(n) from the previous by using integer division instead.
                 </para>
                 <para>
                     Examples follow.
             <pre>
               .
              / \   This contains 1 triangle of size 1.
             .---.
            
                 .
                / \     This contains 4 triangles of size 1.
               .---.    This contains 1 triangle of size 2.
              / \ / \   This contains 5 triangles total.
             .---.---.
            
                   .
                  / \      This contains 9 triangles of size 1.
                 .---.     This contains 3 triangles of size 2.
                / \ / \    This contains 1 triangles of size 3.
               .---.---.
              / \ / \ / \  This contains 13 triangles total.
             .---.---.---.
             </pre>
                 </para>
             </summary>
        </member>
        <member name="T:Algorithms.Sequences.NaturalSequence">
            <summary>
                <para>
                    Sequence of natural numbers.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Natural_number.
                </para>
                <para>
                    OEIS: https://oeis.org/A000027.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.NaturalSequence.Sequence">
            <summary>
                Gets sequence of natural numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.NegativeIntegersSequence">
            <summary>
                <para>
                    Sequence of negative integers.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Negative_number.
                </para>
                <para>
                    OEIS: http://oeis.org/A001478.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.NegativeIntegersSequence.Sequence">
            <summary>
            Gets sequence of negative integers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.NumberOfBooleanFunctionsSequence">
            <summary>
                <para>
                    Sequence of number of truth tables generated by Boolean expressions of n variables
                    (Double exponentials of 2: a(n) = 2^(2^n)).
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Truth_table.
                </para>
                <para>
                    OEIS: https://oeis.org/A001146.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.NumberOfBooleanFunctionsSequence.Sequence">
            <summary>
            Gets sequence of number Of Boolean functions.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.NumberOfPrimesByNumberOfDigitsSequence">
            <summary>
                <para>
                    Number of primes with n digits
                    (The number of primes between 10^(n-1) and 10^n).
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Prime-counting_function.
                </para>
                <para>
                    OEIS: https://oeis.org/A006879.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.NumberOfPrimesByNumberOfDigitsSequence.Sequence">
            <summary>
            Gets sequence of number of primes.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.NumberOfPrimesByPowersOf10Sequence">
            <summary>
                <para>
                    Sequence of number of primes less than 10^n (with at most n digits).
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Prime-counting_function.
                </para>
                <para>
                    OEIS: https://oeis.org/A006880.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.NumberOfPrimesByPowersOf10Sequence.Sequence">
            <summary>
            Gets sequence of numbers of primes.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.OnesCountingSequence">
            <summary>
                <para>
                    1's-counting sequence: number of 1's in binary expression of n.
                </para>
                <para>
                    OEIS: https://oeis.org/A000120.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.OnesCountingSequence.Sequence">
            <summary>
                <para>
                    Gets the generated sequence of the 1's contained in the binary representation of n.
                </para>
                <para>
                    The sequence is generated as follows.
                    1. The initial 0 value is provided.
                    2. A recursively generated sequence is iterated, starting with a length of 1 (i.e., 2^0),
                       followed by increasing 2^x length values.
                    3. Each sequence starts with the value 1, and a targeted value of depths that it will recurse
                       for the specific iteration.
                    4. If the call depth to the recursive function is met, it returns the value argument received.
                    5. If the call depth has not been met, it recurses to create 2 sequences, one starting with the
                       value argument, and the following with the value argument + 1.
                    6. Using ':' as a visual separator for each sequence, this results in the following sequences
                       that are returned sequentially after the initial 0.
                       1 : 1, 2 : 1, 2, 2, 3 : 1, 2, 2, 3, 2, 3, 3, 4.
                </para>
                <remarks>
                    <para>
                    This one comes from thinking over information contained within the COMMENTS section of the OEIS page.
                    </para>
                    <para>
                        Using the comments provided by Benoit Cloitre, Robert G. Wilson v, and Daniel Forgues, the above
                        algorithm was coded.
                    </para>
                </remarks>
            </summary>
        </member>
        <member name="M:Algorithms.Sequences.OnesCountingSequence.GenerateFractalCount(System.Numerics.BigInteger,System.Int32)">
            <summary>
                <para>
                    Recursive function to generate sequences.
                </para>
            </summary>
            <param name="i">The value that will start off the current IEnumerable sequence.</param>
            <param name="depth">The remaining depth of recursion.  Value of 0 is the stop condition.</param>
            <returns>An IEnumerable sequence of BigInteger values that can be iterated over.</returns>
        </member>
        <member name="T:Algorithms.Sequences.PowersOf10Sequence">
            <summary>
                <para>
                    Sequence of powers of 10: a(n) = 10^n.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Power_of_10.
                </para>
                <para>
                    OEIS: https://oeis.org/A011557.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.PowersOf10Sequence.Sequence">
            <summary>
            Gets sequence of powers of 10.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.PowersOf2Sequence">
            <summary>
                <para>
                    Sequence of powers of 2: a(n) = 2^n.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Power_of_two.
                </para>
                <para>
                    OEIS: https://oeis.org/A000079.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.PowersOf2Sequence.Sequence">
            <summary>
            Gets sequence of powers of 2.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.PrimePiSequence">
            <summary>
                <para>
                    Sequence of number of primes less than or equal to n (PrimePi(n)).
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Prime-counting_function.
                </para>
                <para>
                    OEIS: https://oeis.org/A000720.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.PrimePiSequence.Sequence">
            <summary>
            Gets sequence of number of primes.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.PrimesSequence">
            <summary>
                <para>
                    Sequence of prime numbers.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Prime_number.
                </para>
                <para>
                    OEIS: https://oeis.org/A000040.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.PrimesSequence.Sequence">
            <summary>
                Gets sequence of prime numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.PrimorialNumbersSequence">
            <summary>
                <para>
                    Sequence of primorial numbers: product of first n primes.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Primorial.
                </para>
                <para>
                    OEIS: https://oeis.org/A002110.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.PrimorialNumbersSequence.Sequence">
            <summary>
            Gets sequence of primorial numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.RecamansSequence">
            <summary>
                <para>
                    Recaman's sequence. a(0) = 0; for n > 0, a(n) = a(n-1) - n if nonnegative and not already in the sequence, otherwise a(n) = a(n-1) + n.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Recam%C3%A1n%27s_sequence.
                </para>
                <para>
                    OEIS: http://oeis.org/A005132.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.RecamansSequence.Sequence">
            <summary>
                Gets Recaman's sequence.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.SquaresSequence">
            <summary>
                <para>
                    Sequence of square numbers.
                </para>
                <para>
                    Wikipedia: https://wikipedia.org/wiki/Square_number.
                </para>
                <para>
                    OEIS: http://oeis.org/A000290.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.SquaresSequence.Sequence">
            <summary>
            Gets sequence of square numbers.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.TetrahedralSequence">
            <summary>
                <para>
                    Sequence of tetrahedral (triangular pyramids) counts for n >= 0.
                </para>
                <para>
                    OEIS: http://oeis.org/A000292.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Tetrahedral_number.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.TetrahedralSequence.Sequence">
            <summary>
                <para>
                    Gets the value of packing spheres in a regular tetrahedron
                    with increasing by 1 triangular numbers under each layer.
                </para>
                <para>
                    It can be reviewed by starting at the 4th row of Pascal's Triangle
                    following the diagonal values going into the triangle.
                </para>
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.TetranacciNumbersSequence">
            <summary>
                <para>
                    Tetranacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) + a(n-4) with a(0) = a(1) = a(2) = a(3) = 1.
                </para>
                <para>
                    OEIS: https://oeis.org/A000288.
                </para>
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.ThreeNPlusOneStepsSequence">
            <summary>
                <para>
                    Number of halving and tripling steps to reach 1 in the '3n+1' problem.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Collatz_conjecture.
                </para>
                <para>
                    OEIS: https://oeis.org/A006577.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.ThreeNPlusOneStepsSequence.Sequence">
            <summary>
            Gets sequence of number of halving and tripling steps to reach 1 in the '3n+1' problem.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.TribonacciNumbersSequence">
            <summary>
                <para>
                    Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) with a(0)=a(1)=a(2)=1.
                </para>
                <para>
                    OEIS: https://oeis.org/A000213.
                </para>
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.VanEcksSequence">
            <summary>
                <para>
                    Van Eck's sequence. For n >= 1, if there exists an m &lt; n such that a(m) = a(n), take the largest such m and set a(n+1) = n-m; otherwise a(n+1) = 0. Start with a(1)=0.
                </para>
                <para>
                    OEIS: http://oeis.org/A181391.
                </para>
            </summary>
        </member>
        <member name="P:Algorithms.Sequences.VanEcksSequence.Sequence">
            <summary>
                Gets Van Eck's sequence.
            </summary>
        </member>
        <member name="T:Algorithms.Sequences.ZeroSequence">
            <summary>
                <para>
                    The zero sequence.
                </para>
                <para>
                    OEIS: https://oeis.org/A000004.
                </para>
            </summary>
        </member>
        <member name="T:Algorithms.Shufflers.FisherYatesShuffler`1">
            <summary>
                Fisher-Yates shuffle is a simple shuffling algorithm,
                which is usually used to shuffle a deck of cards.
            </summary>
            <typeparam name="T">Type array input.</typeparam>
        </member>
        <member name="M:Algorithms.Shufflers.FisherYatesShuffler`1.Shuffle(`0[],System.Nullable{System.Int32})">
            <summary>
                Shuffles input array using Fisher-Yates algorithm.
                The algorithm starts shuffling from the last element
                and swap elements one by one. We use random index to
                choose element we use in swap operation.
            </summary>
            <param name="array">Array to shuffle.</param>
            <param name="seed">Random generator seed. Used to repeat the shuffle.</param>
        </member>
        <member name="T:Algorithms.Shufflers.IShuffler`1">
            <summary>
                Shuffles array.
            </summary>
            <typeparam name="T">Type of array item.</typeparam>
        </member>
        <member name="M:Algorithms.Shufflers.IShuffler`1.Shuffle(`0[],System.Nullable{System.Int32})">
            <summary>
                Shuffles array.
            </summary>
            <param name="array">Array to Shuffle.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.BinaryInsertionSorter`1">
            <summary>
                TODO.
            </summary>
            <typeparam name="T">TODO. 2.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.BinaryInsertionSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using specified comparer,
                variant of insertion sort where binary search is used to find place for next element
                internal, in-place, unstable,
                time complexity: O(n^2),
                space complexity: O(1),
                where n - array length.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.BinaryInsertionSorter`1.BinarySearch(`0[],System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>Implementation of Binary Search using an iterative approach.</summary>
            <param name="array">
                An array of values sorted in ascending order between the index values left and right to search
                through.
            </param>
            <param name="from">Left index to search from (inclusive).</param>
            <param name="to">Right index to search to (inclusive).</param>
            <param name="target">The value to find placefor in the provided array.</param>
            <param name="comparer">TODO.</param>
            <returns>The index where to insert target value.</returns>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.BogoSorter`1">
            <summary>
                Class that implements bogo sort algorithm.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.BogoSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                TODO.
            </summary>
            <param name="array">TODO. 2.</param>
            <param name="comparer">TODO. 3.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.BubbleSorter`1">
            <summary>
                Class that implements bubble sort algorithm.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.BubbleSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using specified comparer,
                internal, in-place, stable,
                time complexity: O(n^2),
                space complexity: O(1),
                where n - array length.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.CocktailSorter`1">
            <summary>
                Cocktail Sort is a variation of Bubble sort, where Cocktail
                Sort traverses through a given array in both directions alternatively.
            </summary>
            <typeparam name="T">Array input type.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.CocktailSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using Cocktail sort algorithm.
            </summary>
            <param name="array">Input array.</param>
            <param name="comparer">Type of comparer for array elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.CombSorter`1">
            <summary>
                Comb sort is a relatively simple sorting algorithm that improves on bubble sort.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.CombSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using specified comparer,
                internal, in-place, unstable,
                worst case performance: O(n^2),
                best case performance: O(n log(n)),
                average performance: O(n^2 / 2^p),
                space complexity: O(1),
                where n - array length and p - number of increments.
                See <a href="https://en.wikipedia.org/wiki/Comb_sort">here</a> for more info.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.CycleSorter`1">
            <summary>
                Cycle sort is an in-place, unstable sorting algorithm,
                a comparison sort that is theoretically optimal in terms of the total
                number of writes to the original array.
                It is based on the idea that the permutation to be sorted can be factored
                into cycles, which can individually be rotated to give a sorted result.
            </summary>
            <typeparam name="T">Type array input.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.CycleSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts input array using Cycle sort.
            </summary>
            <param name="array">Input array.</param>
            <param name="comparer">Integer comparer.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.ExchangeSorter`1">
            <summary>
                Class that implements exchange sort algorithm.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.ExchangeSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using specified comparer,
                internal, in-place, stable,
                time complexity: O(n^2),
                space complexity: O(1),
                where n - array length.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.HeapSorter`1">
            <summary>
                Heap sort is a comparison based sorting technique
                based on Binary Heap data structure.
            </summary>
            <typeparam name="T">Input array type.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.HeapSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts input array using heap sort algorithm.
            </summary>
            <param name="array">Input array.</param>
            <param name="comparer">Comparer type for elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.IComparisonSorter`1">
            <summary>
                Sorts array in ascending order using comparison sort.
            </summary>
            <typeparam name="T">Type of array item.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.IComparisonSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array in ascending order.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Comparer to compare items of <paramref name="array" />.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.InsertionSorter`1">
            <summary>
                Class that implements insertion sort algorithm.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.InsertionSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using specified comparer,
                internal, in-place, stable,
                time complexity: O(n^2),
                space complexity: O(1),
                where n - array length.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.MedianOfThreeQuickSorter`1">
            <summary>
                Sorts arrays using quicksort (selecting median of three as a pivot).
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.MergeSorter`1">
            <summary>
                Divide and Conquer algorithm, which splits
                array in two halves, calls itself for the two
                halves and then merges the two sorted halves.
            </summary>
            <typeparam name="T">Type of array elements.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.MergeSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using merge sort algorithm,
                originally designed as external sorting algorithm,
                internal, stable,
                time complexity: O(n log(n)),
                space complexity: O(n),
                where n - array length.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Comparer to compare elements of <paramref name="array" />.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.MiddlePointQuickSorter`1">
            <summary>
                Sorts arrays using quicksort (selecting middle point as a pivot).
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.PancakeSorter`1">
            <summary>
                Class that implements pancake sort algorithm.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.PancakeSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using specified comparer,
                internal, in-place, stable,
                time complexity: O(n^2),
                space complexity: O(1),
                where n - array length.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.QuickSorter`1">
            <summary>
                Sorts arrays using quicksort.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.QuickSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using Hoare partition scheme,
                internal, in-place,
                time complexity average: O(n log(n)),
                time complexity worst: O(n^2),
                space complexity: O(log(n)),
                where n - array length.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.RandomPivotQuickSorter`1">
            <summary>
                Sorts arrays using quicksort (selecting random point as a pivot).
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.SelectionSorter`1">
            <summary>
                Class that implements selection sort algorithm.
            </summary>
            <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.SelectionSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using specified comparer,
                internal, in-place, stable,
                time complexity: O(n^2),
                space complexity: O(1),
                where n - array length.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.ShellSorter`1">
            <summary>
                TODO.
            </summary>
            <typeparam name="T">TODO. 2.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.ShellSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using specified comparer,
                based on bubble sort,
                internal, in-place, unstable,
                worst-case time complexity: O(n^2),
                space complexity: O(1),
                where n - array length.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.TimSorter`1">
             <summary>
                 Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data.
                 It was originally implemented by Tim Peters in 2002 for use in the Python programming language.
            
                 This class is based on a Java interpretation of Tim Peter's original work.
                 Java class is viewable here:
                 http://cr.openjdk.java.net/~martin/webrevs/openjdk7/timsort/raw_files/new/src/share/classes/java/util/TimSort.java
            
                 Tim Peters's list sort for Python, is described in detail here:
                 http://svn.python.org/projects/python/trunk/Objects/listsort.txt
            
                 Tim's C code may be found here: http://svn.python.org/projects/python/trunk/Objects/listobject.c
            
                 The underlying techniques are described in this paper (and may have even earlier origins):
                 "Optimistic Sorting and Information Theoretic Complexity"
                 Peter McIlroy
                 SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
                 pp 467-474, Austin, Texas, 25-27 January 1993.
             </summary>
             <typeparam name="T">Type of array element.</typeparam>
        </member>
        <member name="T:Algorithms.Sorters.Comparison.TimSorter`1.TimChunk`1">
            <summary>
            Private class for handling gallop merges, allows for tracking array indexes and wins.
            </summary>
            <typeparam name="Tc">Type of array element.</typeparam>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.Sort(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts array using specified comparer
                worst case performance: O(n log(n)),
                best case performance:  O(n),
                See <a href="https://en.wikipedia.org/wiki/Timsort">here</a> for more info.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="comparer">Compares elements.</param>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.MinRunLength(System.Int32,System.Int32)">
             <summary>
             Returns the minimum acceptable run length for an array of the specified
             length.Natural runs shorter than this will be extended.
            
             Computation is:
               If total less than minRun, return n (it's too small to bother with fancy stuff).
               Else if total is an exact power of 2, return minRun/2.
               Else return an int k, where <![CDATA[minRun/2 <= k <= minRun]]>, such that total/k
                 is close to, but strictly less than, an exact power of 2.
             </summary>
             <param name="total">Total length remaining to sort.</param>
             <returns>Minimum run length to be merged.</returns>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.ReverseRange(`0[],System.Int32,System.Int32)">
            <summary>
            Reverse the specified range of the specified array.
            </summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="start">the index of the first element in the range to be reversed.</param>
            <param name="end">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.BoundLeftShift(System.Int32)">
            <summary>
            Left shift a value, preventing a roll over to negative numbers.
            </summary>
            <param name="shiftable">int value to left shift.</param>
            <returns>Left shifted value, bound to 2,147,483,647.</returns>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.NeedsMerge(Algorithms.Sorters.Comparison.TimSorter{`0}.TimChunk{`0},Algorithms.Sorters.Comparison.TimSorter{`0}.TimChunk{`0},System.Int32@)">
            <summary>
            Check the chunks before getting in to a merge to make sure there's something to actually do.
            </summary>
            <param name="left">TimChunk of the left hand side.</param>
            <param name="right">TimChunk of the right hand side.</param>
            <param name="dest">The current target point for the remaining values.</param>
            <returns>If a merge is required.</returns>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.FinalizeMerge(Algorithms.Sorters.Comparison.TimSorter{`0}.TimChunk{`0},Algorithms.Sorters.Comparison.TimSorter{`0}.TimChunk{`0},System.Int32)">
            <summary>
            Moves over the last parts of the chunks.
            </summary>
            <param name="left">TimChunk of the left hand side.</param>
            <param name="right">TimChunk of the right hand side.</param>
            <param name="dest">The current target point for the remaining values.</param>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.CountRunAndMakeAscending(`0[],System.Int32)">
             <summary>
             Returns the length of the run beginning at the specified position in
             the specified array and reverses the run if it is descending (ensuring
             that the run will always be ascending when the method returns).
            
             A run is the longest ascending sequence with:
            
                <![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]>
            
             or the longest descending sequence with:
            
                <![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]>
            
             For its intended use in a stable mergesort, the strictness of the
             definition of "descending" is needed so that the call can safely
             reverse a descending sequence without violating stability.
             </summary>
             <param name="array">the array in which a run is to be counted and possibly reversed.</param>
             <param name="start">index of the first element in the run.</param>
             <returns>the length of the run beginning at the specified position in the specified array.</returns>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.GallopLeft(`0[],`0,System.Int32,System.Int32,System.Int32)">
            <summary>
            Find the position in the array that a key should fit to the left of where it currently sits.
            </summary>
            <param name="array">Array to search.</param>
            <param name="key">Key to place in the array.</param>
            <param name="i">Base index for the key.</param>
            <param name="len">Length of the chunk to run through.</param>
            <param name="hint">Initial starting position to start from.</param>
            <returns>Offset for the key's location.</returns>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.GallopRight(`0[],`0,System.Int32,System.Int32,System.Int32)">
            <summary>
            Find the position in the array that a key should fit to the right of where it currently sits.
            </summary>
            <param name="array">Array to search.</param>
            <param name="key">Key to place in the array.</param>
            <param name="i">Base index for the key.</param>
            <param name="len">Length of the chunk to run through.</param>
            <param name="hint">Initial starting position to start from.</param>
            <returns>Offset for the key's location.</returns>
        </member>
        <member name="M:Algorithms.Sorters.Comparison.TimSorter`1.BinarySort(`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary
            insertion sort. It requires O(n log n) compares, but O(n^2) data movement.
            </summary>
            <param name="array">Array to sort.</param>
            <param name="start">The index of the first element in the range to be sorted.</param>
            <param name="end">The index after the last element in the range to be sorted.</param>
            <param name="first">The index of the first element in the range that is not already known to be sorted, must be between start and end.</param>
        </member>
        <member name="M:Algorithms.Sorters.External.IExternalSorter`1.Sort(Algorithms.Sorters.External.ISequentialStorage{`0},Algorithms.Sorters.External.ISequentialStorage{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
                Sorts elements in sequential storage in ascending order.
            </summary>
            <param name="mainMemory">Memory that contains array to sort and will contain the result.</param>
            <param name="temporaryMemory">Temporary memory for working purposes.</param>
        </member>
        <member name="T:Algorithms.Sorters.Integer.BucketSorter">
            <summary>
                Class that implements bucket sort algorithm.
            </summary>
        </member>
        <member name="M:Algorithms.Sorters.Integer.BucketSorter.Sort(System.Int32[])">
            <summary>
                Sorts array elements using BucketSort Algorithm.
            </summary>
            <param name="array">Array to sort.</param>
        </member>
        <member name="M:Algorithms.Sorters.Integer.BucketSorter.NumberOfDigits(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
                Determines the number of digits in the largest number.
            </summary>
            <param name="array">Input array.</param>
            <returns>Number of digits.</returns>
        </member>
        <member name="M:Algorithms.Sorters.Integer.BucketSorter.DistributeElements(System.Collections.Generic.IEnumerable{System.Int32},System.Int32[0:,0:],System.Int32)">
            <summary>
                To distribute elements into buckets based on specified digit.
            </summary>
            <param name="data">Input array.</param>
            <param name="buckets">Array of buckets.</param>
            <param name="digit">Digit.</param>
        </member>
        <member name="M:Algorithms.Sorters.Integer.BucketSorter.CollectElements(System.Collections.Generic.IList{System.Int32},System.Int32[0:,0:])">
            <summary>
                Return elements to original array.
            </summary>
            <param name="data">Input array.</param>
            <param name="buckets">Array of buckets.</param>
        </member>
        <member name="M:Algorithms.Sorters.Integer.BucketSorter.EmptyBucket(System.Int32[0:,0:])">
            <summary>
                Sets size of all buckets to zero.
            </summary>
            <param name="buckets">Array of buckets.</param>
        </member>
        <member name="T:Algorithms.Sorters.Integer.CountingSorter">
            <summary>
                Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers; that
                is, it is an integer sorting algorithm. It operates by counting the number of objects that have each distinct key
                value, and using arithmetic on those counts to determine the positions of each key value in the output sequence.
                Its running time is linear in the number of items and the difference between the maximum and minimum key values, so
                it is only suitable for direct use in situations where the variation in keys is not significantly greater than the
                number of items. However, it is often used as a subroutine in another sorting algorithm, radix sort, that can
                handle larger keys more efficiently.
            </summary>
        </member>
        <member name="M:Algorithms.Sorters.Integer.CountingSorter.Sort(System.Int32[])">
            <summary>
                <para>
                    Sorts input array using counting sort algorithm.
                </para>
                <para>
                    Time complexity: O(n+k), where k is the range of the non-negative key values.
                </para>
                <para>
                    Space complexity: O(n+k), where k is the range of the non-negative key values.
                </para>
            </summary>
            <param name="array">Input array.</param>
        </member>
        <member name="T:Algorithms.Sorters.Integer.IIntegerSorter">
            <summary>
                Sorts array of integers without comparing them.
            </summary>
        </member>
        <member name="M:Algorithms.Sorters.Integer.IIntegerSorter.Sort(System.Int32[])">
            <summary>
                Sorts array in ascending order.
            </summary>
            <param name="array">Array to sort.</param>
        </member>
        <member name="T:Algorithms.Sorters.Integer.RadixSorter">
            <summary>
                Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the
                individual
                digits which share the same significant position and value. A positional notation is required, but because integers
                can represent
                strings of characters (e.g., names or dates) and specially formatted floating point numbers, radix sort is not
                limited to integers.
            </summary>
        </member>
        <member name="M:Algorithms.Sorters.Integer.RadixSorter.Sort(System.Int32[])">
            <summary>
                Sorts array in ascending order.
            </summary>
            <param name="array">Array to sort.</param>
        </member>
        <member name="T:Algorithms.Sorters.String.IStringSorter">
            <summary>
                Sorts array of strings without comparing them.
            </summary>
        </member>
        <member name="M:Algorithms.Sorters.String.IStringSorter.Sort(System.String[])">
            <summary>
                Sorts array in ascending order.
            </summary>
            <param name="array">Array to sort.</param>
        </member>
        <member name="T:Algorithms.Sorters.String.MsdRadixStringSorter">
            <summary>
                Radix sort is a non-comparative sorting algorithm. It avoids comparison by creating
                and distributing elements into buckets according to their radix.
                Radix sorts can be implemented to start at either the most significant digit (MSD)
                or least significant digit (LSD).
                MSD radix sorts are most suitable for sorting array of strings with variable length
                in lexicographical order.
            </summary>
        </member>
        <member name="M:Algorithms.Sorters.String.MsdRadixStringSorter.Sort(System.String[])">
            <summary>
                Sort array of strings using MSD radix sort algorithm.
            </summary>
            <param name="array">Array to sort.</param>
        </member>
        <member name="T:Algorithms.Strings.GeneralStringAlgorithms">
            <summary>
                Implements simple algorithms on strings.
            </summary>
        </member>
        <member name="M:Algorithms.Strings.GeneralStringAlgorithms.FindLongestConsecutiveCharacters(System.String)">
            <summary>
                Finds character that creates longest consecutive substring with single character.
            </summary>
            <param name="input">String to find in.</param>
            <returns>Tuple containing char and number of times it appeared in a row.</returns>
        </member>
        <member name="T:Algorithms.Strings.Palindrome">
            <summary>
                Palindrome a series of characters or a string that when reversed,
                equals the original string.
            </summary>
        </member>
        <member name="M:Algorithms.Strings.Palindrome.IsStringPalindrome(System.String)">
            <summary>
                Function to check if a string is a palindrome.
            </summary>
            <param name="word">String being checked.</param>
        </member>
        <member name="M:Algorithms.Strings.Palindrome.TypifyString(System.String)">
            <summary>
                Typify string to lower and remove white spaces.
            </summary>
            <param name="word">String to remove spaces.</param>
            <returns>Returns original string without spaces.</returns>
        </member>
        <member name="M:Algorithms.Strings.Palindrome.ReverseString(System.String)">
            <summary>
                Helper function that returns a reversed string inputed.
            </summary>
            <param name="s">String to be reversed.</param>
            <returns>Returns s reversed.</returns>
        </member>
        <member name="T:Algorithms.Strings.PatternMatching.BoyerMoore">
            <summary>
                The idea:   You compare the pattern with the text from right to left.
                If the text symbol that is compared with the rightmost pattern symbol
                does not occur in the pattern at all, then the pattern can be shifted
                by m positions behind this text symbol.
                Complexity:
                Time:   Preprocessing: O(m²)
                Comparison: O(mn)
                Space:  O(m + a)
                where   m - pattern length
                n - text length
                a - alphabet length.
                Source:     https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/bmen.htm
                https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm.
            </summary>
        </member>
        <member name="M:Algorithms.Strings.PatternMatching.BoyerMoore.FindFirstOccurrence(System.String,System.String)">
            <summary>
                Finds the index of the first occurrence of the pattern <c>p</c> in <c>t</c>.
            </summary>
            <param name="t">Input text.</param>
            <param name="p">Search pattern.</param>
            <returns>Index of the pattern in text or -1 if the pattern  was not found.</returns>
        </member>
        <member name="M:Algorithms.Strings.PatternMatching.BoyerMoore.BadCharacterRule(System.String,System.Int32)">
            <summary>
                Finds out the position of its rightmost occurrence in the pattern for each symbol of the alphabet,
                or -1 if the symbol does not occur in the pattern.
            </summary>
            <param name="p">Search pattern.</param>
            <param name="m">Length of the pattern.</param>
            <returns>Array of the named postition for each symbol of the alphabet.</returns>
        </member>
        <member name="M:Algorithms.Strings.PatternMatching.BoyerMoore.GoodSuffixRule(System.String,System.Int32)">
            <summary>
                Finds out the shift distance of the pattern if a mismatch at position i – 1 occurs
                for each character of the pattern, i.e. if the suffix of the pattern starting at position i has matched.
            </summary>
            <param name="p">Search pattern.</param>
            <param name="m">Length of the pattern.</param>
            <returns>Array of the named shift distance for each character of the pattern.</returns>
        </member>
        <member name="M:Algorithms.Strings.PatternMatching.KnuthMorrisPrattSearcher.FindIndexes(System.String,System.String)">
            <summary>
                An implementation of Knuth–Morris–Pratt Algorithm.
                Worst case time complexity: O(n + k)
                where n - text length, k - pattern length.
            </summary>
            <param name="str">The string to look in.</param>
            <param name="pat">The pattern to look for.</param>
            <returns>
                The zero-based positions of all occurrences of <paramref name="pat" /> in <paramref name="str" />.
            </returns>
        </member>
        <member name="M:Algorithms.Strings.PatternMatching.KnuthMorrisPrattSearcher.FindLongestPrefixSuffixValues(System.String)">
            <summary>
                Return the longest prefix suffix values for pattern.
            </summary>
            <param name="pat">pattern to seek.</param>
            <returns>The longest prefix suffix values for <paramref name="pat" />.</returns>
        </member>
        <member name="T:Algorithms.Strings.PatternMatching.NaiveStringSearch">
            <summary>
                Implements the traditional naive string matching algorithm in C#.
            </summary>
        </member>
        <member name="M:Algorithms.Strings.PatternMatching.NaiveStringSearch.NaiveSearch(System.String,System.String)">
            <summary>
                NaiveSearch(Content, Pattern) will return an array containing each index of Content in which Pattern appears.
                Cost:  O(n*m).
            </summary>
            <param name="content">The text body across which to search for a given pattern.</param>
            <param name="pattern">The pattern against which to check the given text body.</param>
            <returns>Array containing each index of Content in which Pattern appears.</returns>
        </member>
        <member name="T:Algorithms.Strings.PatternMatching.RabinKarp">
            <summary>
                The idea: You calculate the hash for the pattern <c>p</c> and the hash values for all the prefixes of the text
                <c>t</c>.
                Now, you can compare a substring in constant time using the calculated hashes.
                time complexity: O(p + t),
                space complexity: O(t),
                where   t - text length
                p - pattern length.
            </summary>
        </member>
        <member name="M:Algorithms.Strings.PatternMatching.RabinKarp.FindAllOccurrences(System.String,System.String)">
            <summary>
                Finds the index of all occurrences of the pattern <c>p</c> int <c>t</c>.
            </summary>
            <returns>List of starting indices of the pattern in the text.</returns>
        </member>
        <member name="T:Algorithms.Strings.PatternMatching.ZblockSubstringSearch">
            <summary>Implementation Z-block substring search.
            </summary>
        </member>
        <member name="M:Algorithms.Strings.PatternMatching.ZblockSubstringSearch.FindSubstring(System.String,System.String)">
            <summary>
                This algorithm finds all occurrences of a pattern in a text in linear time - O(m+n).
            </summary>
        </member>
        <member name="M:Algorithms.Strings.Permutation.GetEveryUniquePermutation(System.String)">
            <summary>
            Returns every anagram of a given word.
            </summary>
            <returns>List of anagrams.</returns>
        </member>
        <member name="T:Algorithms.Strings.Similarity.HammingDistance">
            <summary>
                <para>
                    Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different.
                    Time complexity is O(n) where n is the length of the string.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Hamming_distance.
                </para>
            </summary>
        </member>
        <member name="M:Algorithms.Strings.Similarity.HammingDistance.Calculate(System.String,System.String)">
            <summary>
                Calculates Hamming distance between two strings of equal length.
            </summary>
            <param name="s1">First string.</param>
            <param name="s2">Second string.</param>
            <returns>Levenshtein distance between source and target strings.</returns>
        </member>
        <member name="T:Algorithms.Strings.Similarity.JaccardDistance">
            <summary>
             <para>
            Jaccard distance is a measure of two sets of data are. It is calculated by subtracting the Jaccard similarity
            coefficient from 1, or, equivalently by dividing the difference of the sizes of the union and intersection of two sets
            by the size of the union.
            </para>
            <para>
            For example, suppose we have two sets of words:
            <list type="bullet">
            <item>
            A = {apple, banana, cherry, date}
            </item>
            <item>
            B = {banana, cherry, elderberry, fig}
            </item>
            </list>
            </para>
            <para>
            The number of common elements in both sets is 2 (banana and cherry). The number of elements in either set is 6
            (apple, banana, cherry, date, elderberry, fig).
            </para>
            <para>
            The Jaccard similarity coefficient is 2 / 6 = 0.333333 or 33.333% similarity.
            </para>
            <para>
            The Jaccard distance is 1 - 0.33333 = 0.66667. This means that the two sets are about 67% different.
            </para>
            <para>
            Jaccard distance is commonly used to calculate a matrix of clustering and multidimensional scaling of sample tests.
            </para>
            </summary>
        </member>
        <member name="M:Algorithms.Strings.Similarity.JaccardDistance.Calculate(System.String,System.String)">
            <summary>
            Calculate the Jaccard distance between to strings.
            </summary>
            <param name="left">The first string.</param>
            <param name="right">The second string.</param>
            <returns>The Jaccard distance.</returns>
        </member>
        <member name="T:Algorithms.Strings.Similarity.JaccardSimilarity">
            <summary>
             <para>
            Jaccard similarity is a statistic that measures how similar two sets of data are. It is calculated by dividing
            the number of common elements in both sets by the number of elements in either set. More formally, it is the
            quotient of the division of the size of the size of the intersection divided by the size of the union of two sets.
            </para>
            <para>
            The result is a value between 0 and 1, where 0 means no similarity and 1 means perfect similarity.
            </para>
            <para>
            For example, suppose we have two sets of words:
            <list type="bullet">
            <item>
            A = {apple, banana, cherry, date}
            </item>
            <item>
            B = {banana, cherry, elderberry, fig}
            </item>
            </list>
            </para>
            <para>
            The number of common elements in both sets is 2 (banana and cherry). The number of elements in either set is 6
            (apple, banana, cherry, date, elderberry, fig).
            </para>
            <para>
            The Jaccard similarity coefficient is 2 / 6 = 0.333333 or 33.333% similarity.
            </para>
            </summary>
        </member>
        <member name="M:Algorithms.Strings.Similarity.JaccardSimilarity.Calculate(System.String,System.String)">
            <summary>
            Calculates the Jaccard similarity coefficient between two strings.
            </summary>
            <param name="left">The first string to compare.</param>
            <param name="right">The second string to compare.</param>
            <returns>A double value between 0 and 1 that represents the similarity of the two strings.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when either the input is null.</exception>
            <remarks>
            This method uses a HashSet to represent the sets of characters in the input strings.
            </remarks>
        </member>
        <member name="M:Algorithms.Strings.Similarity.JaccardSimilarity.ValidateInput(System.String,System.String)">
            <summary>
            Validates the input strings and throws an exception if either is null.
            </summary>
            <param name="left">The first string to validate.</param>
            <param name="right">The second string to validate.</param>
        </member>
        <member name="T:Algorithms.Strings.Similarity.JaroSimilarity">
            <summary>
                <para>
                    Jaro Similarity measures how similar two strings are.
                    Result is between 0 and 1 where 0 represnts that there is no similarity between strings and 1 represents equal strings.
                    Time complexity is O(a*b) where a is the length of the first string and b is the length of the second string.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance#Jaro_similarity.
                </para>
            </summary>
        </member>
        <member name="M:Algorithms.Strings.Similarity.JaroSimilarity.Calculate(System.String,System.String)">
            <summary>
                Calculates Jaro Similarity between two strings.
            </summary>
            <param name="s1">First string.</param>
            <param name="s2">Second string.</param>
        </member>
        <member name="M:Algorithms.Strings.Similarity.JaroSimilarity.CalculateTranspositions(System.String,System.String,System.Boolean[],System.Boolean[])">
            <summary>
                Calculates number of matched characters that are not in the right order.
            </summary>
        </member>
        <member name="T:Algorithms.Strings.Similarity.JaroWinklerDistance">
            <summary>
                <para>
                    Jaro–Winkler distance is a string metric measuring an edit distance between two sequences.
                    The score is normalized such that 1 means an exact match and 0 means there is no similarity.
                    Time complexity is O(a*b) where a is the length of the first string and b is the length of the second string.
                </para>
                <para>
                    Wikipedia: https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance.
                </para>
            </summary>
        </member>
        <member name="M:Algorithms.Strings.Similarity.JaroWinklerDistance.Calculate(System.String,System.String,System.Double)">
            <summary>
                Calculates Jaro–Winkler distance.
            </summary>
            <param name="s1">First string.</param>
            <param name="s2">Second string.</param>
            <param name="scalingFactor">Scaling factor for how much the score is adjusted upwards for having common prefixes. Default is 0.1.</param>
            <returns>Distance between two strings.</returns>
        </member>
    </members>
</doc>
